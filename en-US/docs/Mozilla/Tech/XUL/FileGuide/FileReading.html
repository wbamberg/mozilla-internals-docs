<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/zilla-slab.css"/>
    <link rel="stylesheet" href="/css/page.css"/>
    <title>Reading from Files</title>
  </head>

  <body><nav class="breadcrumbs"><a href="../../../../Mozilla.html">Mozilla</a>&raquo;<a href="../../../Tech.html">Tech</a>&raquo;<a href="../../XUL.html">XUL</a>&raquo;<a href="../FileGuide.html">FileGuide</a></nav><div class="content-heading"><h1>Reading from Files</h1></div>
<div class="content"><p>
</p>
<p>
 <strong>
  <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/IO" title="FileGuide/IO">
   File and Stream Guide
  </a>
  :
 </strong>
 <strong>
  [
 </strong>
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO" title="">
   nsIScriptableIO
  </a>
 </code>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/Accessing_Files" title="FileGuide/Accessing_Files">
  Accessing Files
 </a>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/FileInfo" title="FileGuide/FileInfo">
  Getting File Information
 </a>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/FileReading" title="FileGuide/FileReading">
  Reading from Files
 </a>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/FileWriting" title="FileGuide/FileWriting">
  Writing to Files
 </a>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/MoveCopyDelete" title="FileGuide/MoveCopyDelete">
  Moving, Copying and Deleting Files
 </a>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/FileUpDown" title="FileGuide/FileUpDown">
  Uploading and Downloading Files
 </a>
 |
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/Directories" title="FileGuide/Directories">
  Working With Directories
 </a>
 <strong>
  ]
 </strong>
</p>
<div class="warning">
 <strong>
  Important note:
 </strong>
 The pages from the
 <em>
  File and Stream Guide
 </em>
 use the
 <code>
  IO
 </code>
 object (
 <code>
  nsIScriptableIO
 </code>
 ), which was not available in any released version of the platform (pending
 <a class="link-https" href="https://bugzilla.mozilla.org/show_bug.cgi?id=396051" title="https://bugzilla.mozilla.org/show_bug.cgi?id=396051">
  some fixes
 </a>
 ). There are alternative XPCOM APIs you can use, your help in updating this pages to use the supported API is very much welcome!
</div>
<p>
 Other documentation on files and I/O not using the unavailable nsIScriptableIO APIs:
 <a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Code_snippets/File_I_O">
  Code snippets: File I/O
 </a>
 ,
 <a href="/en-US/docs/Mozilla/Tech/XUL/Tutorial/Open_and_Save_Dialogs">
  Open and Save Dialogs
 </a>
 ,
 <a href="https://developer.mozilla.org/en-US/docs/Archive/Mozilla/Reading_textual_data">
  Reading textual data
 </a>
 ,
 <a href="https://developer.mozilla.org/en-US/docs/Archive/Mozilla/Writing_textual_data">
  Writing textual data
 </a>
 ,
 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Errors">
  List of file-related error codes
 </a>
 .
</p>
<p>
</p>
<p>
 Reading data from a file involves getting a reference to a file and then creating an
 <a href="https://developer.mozilla.org/en-US/InputStream" title="en/InputStream">
  input stream
 </a>
 to read from it. An input stream provides a means of reading bytes, strings or other values from the file. While there is only one method to create an input stream, it provides a number of options to control exactly how reading is performed. For instance, there are options to read a file as if it were text or a binary file. Using the former will cause characters in the stream to be interpreted with a particular character encoding. In addition, lines may be read by reading the file up until a linefeed character is detected. A binary stream would be used to read bytes or numbers encoded within the file.
</p>
<p>
 To create an input stream, first get a reference to a
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIFile" title="">
   nsIFile
  </a>
 </code>
 , and then use
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO">
   nsIScriptableIO.newInputStream()
  </a>
 </code>
 to open a stream for reading from it. To learn more about file objects, see
 <a href="/en-US/docs/Mozilla/Tech/XUL/FileGuide/IO" title="en/FileGuide/IO">
  Files and Streams
 </a>
 .
</p>
<pre>var file = IO.getFile("Home", "sample.txt");
var stream = IO.newInputStream(file, "text");
</pre>
<p>
 This example first retrieves a file object using
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO">
   nsIScriptableIO.getFile()
  </a>
 </code>
 . In this case, the file 'sample.txt' within the user's home directory is retrieved. Next,
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO">
   nsIScriptableIO.newInputStream()
  </a>
 </code>
 is called to create a new input stream for reading from the file. This method will open the file and return a stream. Naturally, if the file does not exist, an error will occur. You may wish to use
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIFile">
   nsIFile.exists()
  </a>
 </code>
 to check if the file exists before opening it.
</p>
<p>
 In fact, it is a good idea to enclose file reading and writing operations within a try-catch block to capture any errors that might occur during the process. See
 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Errors" title="en/Table_Of_Errors#File_Errors">
  File Errors
 </a>
 for a list of errors that might occur.
</p>
<p>
 The
 <code>
  newInputStream
 </code>
 method takes two arguments in this example. The first argument is the file to read from, and the second is a set of flags which control the reading. In this case, the 'text' flag is used which indicates that you expect this file to be text file. This method actually takes a number of additional arguments, however they are optional so they do not need to be specified if they aren't needed. These extra arguments will be discussed later.
</p>
<p>
 You can also specify to read from a binary file by using the flag 'binary' instead of 'text'. The difference is that text streams process the bytes being read into characters in a particular character encoding whereas binary streams always read bytes. First, let's look at reading form text files.
</p>
<h4 id="Reading_Text_Files" name="Reading_Text_Files">
 Reading Text Files
</h4>
<p>
 Characters are interpreted from a text input stream using a specified character encoding. This means that if a character within the file occupies several bytes, it will converted into a single character when read. This is done automatically as long as you specify the 'text' flag to
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO">
   nsIScriptableIO.newInputStream()
  </a>
 </code>
 . The default character encoding is UTF-8 which means that characters below value 128 will occupy a single byte whereas characters above value 128 will occupy multiple bytes, depending on their value. However, a number of other character encodings are available; see
 <a href="#Reading_Other_Character_Encodings">
  Reading Other Character Encodings
 </a>
 below for details about reading text in other encodings.
</p>
<p>
 There are several methods available to read from an input stream. The two most common for text files are the
 <a href="https://developer.mozilla.org/en-US/InputStream/readString" title="en/InputStream/readString">
  readString
 </a>
 and
 <a href="https://developer.mozilla.org/en-US/InputStream/readLine" title="en/InputStream/readLine">
  readLine
 </a>
 methods for reading a string and a line from the file respectively.
</p>
<pre>var file = IO.getFile("Home", "sample.txt");
var stream = IO.newInputStream(file, "text");
var str = stream.readString(20);
stream.close();
</pre>
<p>
 In this example, a text input stream is created for the file 'sample.txt'. The
 <code>
  readString
 </code>
 method is called to read a 20 character string from the file. Since the stream was just opened, the string will be read from the beginning of the file. A further read from the file will read additional characters after the first 20. The
 <code>
  readString
 </code>
 takes one argument, the number of characters to read from the file. Note that this is distinct from the number of bytes to read. Depending on the character encoding, it is possible that more than 20 bytes will be read from the file in order to retrieve 20 characters from the file.
</p>
<p>
 The
 <code>
  readString
 </code>
 method returns the string read from the stream. Usually this string have a length equal to the number of characters that were requested. However, it may not do, for instance if the end of the file was reached. This doesn't trigger an error, and the string will just be returned containing as many characters as are available.
</p>
<p>
 You can use the
 <a href="https://developer.mozilla.org/en-US/InputStream/available" title="en/InputStream/available">
  available
 </a>
 method to check if data is available for reading:
</p>
<pre>var file = IO.getFile("Home", "sample.txt");
var stream = IO.newInputStream(file, "text");
var str = stream.readString(stream.available());
stream.close();
</pre>
<p>
 In this example, the
 <code>
  available
 </code>
 method is called to determine the number of available bytes for reading. Note that this method returns the number of bytes available, not the number of characters available, because the file hasn't been read and parsed yet, so the actual number of characters isn't known yet. Fortunately as a character is always at least one byte long in the default UTF-8 encoding, the number of characters will always be equal to or smaller than the number of bytes available. For normal file streams, the
 <code>
  available
 </code>
 method will return the total number of bytes left in the file to read. In effect, the above code ends up reading the entire contents of the file into a single string.
</p>
<p>
 The
 <code>
  available
 </code>
 method returns 0 if there is no more data to read, so you could use a loop to read a number of strings. This example keeps reading 10 character strings from a file until there is no more data to read. Note that the last string read may be less than ten characters long.
</p>
<pre>while(stream.available())
  output += stream.readString(10);
</pre>
<p>
 The
 <a href="https://developer.mozilla.org/en-US/InputStream/close" title="en/InputStream/close">
  close
 </a>
 method is used at the end to close the stream when you are finished reading from it. You should always strive to close a stream when you have finished reading or writing to it to ensure that it doesn't remain open longer than necessary.
</p>
<h5 id="Reading_Lines" name="Reading_Lines">
 Reading Lines
</h5>
<p>
 The
 <a href="https://developer.mozilla.org/en-US/InputStream/readLine" title="en/InputStream/readLine">
  readLine
 </a>
 method may be used to read a line from the file. This method doesn't take a count of characters to read but instead keeps reading until the end of a line is reached. This method handles all the different types of end of line characters and combinations, so you do not need to worry about platform specific conventions. The line read from the file is returned by the
 <code>
  readLine
 </code>
 method. It is important to note that the newline characters themselves are not included in the returned string.
</p>
<pre>var lines = [];
while(stream.available())
  lines.push(stream.readLine());
</pre>
<p>
 In this example, each line from a stream is read and added to an array. The result is an array containing each of the lines in the file.
</p>
<h5 id="Reading_Other_Character_Encodings" name="Reading_Other_Character_Encodings">
 Reading Other Character Encodings
</h5>
<p>
 The default character encoding is UTF-8. If you know that a file is stored using a different encoding, you can specify a third argument to
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO">
   nsIScriptableIO.newInputStream()
  </a>
 </code>
 which specifies the encoding. This example opens a file using the UTF-16 encoding.
</p>
<pre>var stream = IO.newInputStream(file, "text", "UTF-16");
</pre>
<p>
 This third argument is not needed if the file is stored in UTF-8. For a list of supported character encodings, see
 <a href="https://developer.mozilla.org/en-US/docs/Gecko/Character_sets_supported_by_Gecko" title="en/Character_Sets_Supported_by_Gecko">
  Supported Character Sets
 </a>
 .
</p>
<p>
 The files can be read in the same manner using the
 <code>
  readString
 </code>
 and
 <code>
  readLine
 </code>
 methods. The difference is handled internally so you don't need to write any other part of the code differently.
</p>
<h4 id="Reading_Binary_Data" name="Reading_Binary_Data">
 Reading Binary Data
</h4>
<p>
 In addition to text, binary values may be read from a file either as bytes, or interpreted as numbers. A number of methods are available which may be used for this. If you are expecting to read from a binary file instead of text, specify the 'binary' flag when creating the stream with
 <code>
  <a href="/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIScriptableIO">
   nsIScriptableIO.newInputStream()
  </a>
 </code>
 .
</p>
<pre>var stream = IO.newInputStream(file, "binary");
</pre>
<p>
 This line will create and open a binary stream for a file. Once the stream has been opened, you can read from the file using various reading methods. The
 <a href="https://developer.mozilla.org/en-US/InputStream/readString" title="en/InputStream/readString">
  readString
 </a>
 method may be used to read a certain number of bytes into a string. This example will keep reading 20 byte blocks from a file and append them to a string. Note that binary streams do not interpret characters within the stream, so the returned string will only have characters below 256, if you expect to use the data as text.
</p>
<pre>while(stream.available())
  output += stream.readString(20);
</pre>
<p>
 Although this can be a suitable means of reading binary data, usually you will want to retrieve the data with some additional methods that are more useful. The following methods are available:
</p>
<ul>
 <li>
  <a href="https://developer.mozilla.org/en-US/InputStream/readBoolean" title="en/InputStream/readBoolean">
   readBoolean
  </a>
  will read a single byte from a stream and return false if the byte is zero and true if the byte has a non-zero value.
 </li>
 <li>
  <a href="https://developer.mozilla.org/en-US/InputStream/read8" title="en/InputStream/read8">
   read8
  </a>
  will read a single byte and return it. The 8 in the method name indicates that 8 bits of data are being read.
 </li>
 <li>
  <a href="https://developer.mozilla.org/en-US/InputStream/read16" title="en/InputStream/read16">
   read16
  </a>
  will read two bytes from the stream and interpret them as an integer. This method will return the value as a number.
 </li>
 <li>
  <a href="https://developer.mozilla.org/en-US/InputStream/read32" title="en/InputStream/read32">
   read32
  </a>
  will read four bytes and return this as a single 32-bit integer.
 </li>
 <li>
  <a href="https://developer.mozilla.org/en-US/InputStream/readFloat" title="en/InputStream/readFloat">
   readFloat
  </a>
  will read four bytes and interpret them as a floating point value.
 </li>
 <li>
  <a href="https://developer.mozilla.org/en-US/InputStream/readDouble" title="en/InputStream/readDouble">
   readDouble
  </a>
  will read eight bytes and interpret them as a double floating point value.
 </li>
</ul>
<p>
 In this next example, the
 <code>
  read32
 </code>
 method is used to read a 32-bit length from the file. Then, this length is used to determine how many additional bytes of data to read.
</p>
<pre>var length = stream.read32();
var data = stream.readString(length);
</pre>
<p>
 All values are read in big endian form, which means that integers are stored in the file with their higher bits first. For both the read16 and read32 methods, the values are always interpreted as unsigned values. If you want the sign bit to be interpreted such that negative values can be read, you can use a simple calculation to convert the value:
</p>
<pre>var val = stream.read16();
if (val &gt; 0x7fff)
  val = ~(0x10000 - val - 1);
</pre>
<p>
 Sometimes, a file will contain bytes that have the value zero. You can use the
 <code>
  read8
 </code>
 method to read these. The
 <code>
  read
 </code>
 and
 <code>
  readString
 </code>
 methods may not be suitable for this due to zero-values. An additional method that is useful here is the
 <a href="https://developer.mozilla.org/en-US/InputStream/readByteArray" title="en/InputStream/readByteArray">
  readByteArray
 </a>
 method. This method is used to read a number of bytes into an array. Unlike with the other reading methods that read a string, the
 <code>
  readByteArray
 </code>
 method returns an array where each element is a byte of data from the file.
</p>
<pre>var arr = stream.readByteArray(8);
alert("The second byte read was: " + arr[1]); 
</pre>
<p>
 This example uses the
 <code>
  readByteArray
 </code>
 method to read 8 bytes from the stream. Unlike with the
 <code>
  read
 </code>
 and
 <code>
  readString
 </code>
 methods, the
 <code>
  readByteArray
 </code>
 method will fail if there isn't enough data to read. This is also the case of the other number reading methods.
</p></div><div id="footer"><hr/><p>This page was originally written for <a href="https://developer.mozilla.org">developer.mozilla.org</a> and is used here under the <a href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike license</a> (CC-BY-SA).</p>
<p>Original contributors to this page: <a href="https://developer.mozilla.org/en-US/profiles/wbamberg">wbamberg</a>.</p></div></body>
</html>
