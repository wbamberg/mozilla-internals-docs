<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/zilla-slab.css"/>
    <link rel="stylesheet" href="/css/page.css"/>
    <title>Interfacing with the XPCOM cycle collector</title>
  </head>

  <body><nav class="breadcrumbs"><a href="../../../Mozilla.html">Mozilla</a>&raquo;<a href="../../Tech.html">Tech</a>&raquo;<a href="../XPCOM.html">XPCOM</a></nav><div class="content-heading"><h1>Interfacing with the XPCOM cycle collector</h1></div>
<div class="content"><p>This is a quick overview of the cycle collector introduced into XPCOM for Firefox 3, including a description of the steps involved in modifying an existing C++ class to participate in XPCOM cycle collection. If you have a class that you think is involved in a cyclical-ownership leak, this page is for you.</p>

<p>The intended audience is Mozilla C++ developers.</p>

<h2 id="What_the_cycle_collector_does" name="What_the_cycle_collector_does">What the cycle collector does</h2>

<p>The cycle collector spends most of its time accumulating (and forgetting about) pointers to XPCOM objects that <em>might</em> be involved in garbage cycles. This is the idle stage of the collector's operation, in which special variants of <code>nsAutoRefCnt</code> register and unregister themselves very rapidly with the collector, as they pass through a "suspicious" refcount event (from N+1 to N, for nonzero N).</p>

<p>Periodically the collector wakes up and examines any suspicious pointers that have been sitting in its buffer for a while. This is the scanning stage of the collector's operation. In this stage the collector repeatedly asks each candidate for a singleton cycle-collection helper class, and if that helper exists, the collector asks the helper to describe the candidate's (owned) children. This way the collector builds a picture of the ownership subgraph reachable from suspicious objects.</p>

<p>If the collector finds a group of objects that all refer back to one another, and establishes that the objects' reference counts are all accounted for by internal pointers within the group, it considers that group <em>cyclical garbage</em>, which it then attempts to free. This is the unlinking stage of the collectors operation. In this stage the collector walks through the garbage objects it has found, again consulting with their helper objects, asking the helper objects to "unlink" each object from its immediate children.</p>

<p>Note that the collector also knows how to walk through the JS heap, and can locate ownership cycles that pass in and out of it.</p>

<h2 id="How_the_collector_can_fail" name="How_the_collector_can_fail">How the collector can fail</h2>

<p>The cycle collector is a conservative device. There are situations in which it will fail to collect a garbage cycle.</p>

<ol>
 <li>It does not suspect any pointers by default; objects must <em>suspect themselves</em>, typically by using an <code>nsCycleCollectingAutoRefCnt</code> rather than a <code>nsAutoRefCnt</code>.</li>
 <li>It only traverses objects that return a helper object when QI'ed to <code>nsICycleCollectionParticipant</code>. If it encounters an unknown edge during its traversal, it gives up on that edge; this means that every edge involved in a cycle must be participating, otherwise the cycle will not be found.</li>
 <li>The <code>Traverse</code> and <code>Unlink</code> methods on the helper object are not magic; they are programmer-supplied and must be correct, or else the collector will fail.</li>
 <li>The collector does not know how to find temporary owning pointers that exist on the stack, so it is important that it only run from near the top-loop of the program. It will not crash if there are extra owning pointers, but it will find itself unable to account for the reference counts it finds in the owned objects, so may fail to collect cycles.</li>
</ol>

<h2 id="How_to_make_your_classes_participate" name="How_to_make_your_classes_participate">How to make your classes participate</h2>

<p>The interface between the cycle collector and your classes can be accessed directly using the contents of <code>xpcom/base/nsCycleCollector.h</code>, but there are convenience macros for annotating your classes in <code>xpcom/glue/nsCycleCollectionParticipant.h</code> that are much easier to use. In general, assuming you are modifying class <code>nsFoo</code> with two <code>nsCOMPtr</code> edges <code>mBar</code> and <code>mBaz</code>, the process can be distilled to a few simple modifications:</p>

<ol>
 <li>Include the header <code>nsCycleCollectionParticipant.h</code> in both <code>nsFoo.h</code> and <code>nsFoo.cpp</code>.</li>
 <li>Add a line declaring that your class <code>nsFoo</code> participates in the cycle collection in <code>nsFoo.cpp</code>:
  <pre class="brush: cpp">NS_IMPL_CYCLE_COLLECTION_CLASS(nsFoo)</pre>
 </li>
 <li>Change the line <code>NS_DECL_ISUPPORTS</code> to <code>NS_DECL_CYCLE_COLLECTING_ISUPPORTS</code> in the definition of <code>nsFoo</code>.</li>
 <li>
  <p>Add a line <code>NS_DECL_CYCLE_COLLECTION_CLASS(nsFoo)</code> within the public portion of definition of <code>nsFoo</code>. Or <code>NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsFoo, nsIBar)</code> if <code>nsFoo</code> inherits from multiple interfaces, where <code>nsIBar</code> is the interface which is returned when you <code>QueryInterface nsFoo </code>to <code>nsISupports</code>.  (We call <code>nsIBar</code> the canonical <code>ISupports</code> type for <code>nsFoo</code>.)</p>
 </li>
 <li>Add a line <code>NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsFoo)</code> to the interface map of <code>nsFoo</code> in <code>nsFoo.cpp</code>. Or if that doesn't work:
  <pre class="brush: cpp">NS_INTERFACE_TABLE_HEAD(nsFoo)
  NS_INTERFACE_TABLE2(nsFoo, 
                      nsIBar, 
                      nsIBaz)
  NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsFoo)
NS_INTERFACE_MAP_END
</pre>
 </li>
 <li>Change the line <code>NS_IMPL_ADDREF(nsFoo)</code> to <code>NS_IMPL_CYCLE_COLLECTING_ADDREF(nsFoo)</code> in <code>nsFoo.cpp</code>, and similarly change the line <code>NS_IMPL_RELEASE(nsFoo)</code> to <code>NS_IMPL_CYCLE_COLLECTING_RELEASE(nsFoo)</code> in <code>nsFoo.cpp</code>.</li>
 <li>Add the appropriate <code>NS_IMPL_CYCLE_COLLECTION_#</code> macro, where <code># </code>is the number of member variables in your class.  For instance, if <code>nsFoo </code>contains two member variables, <code>mBar </code>and <code>mBaz</code>, we'd add <code>NS_IMPL_CYCLE_COLLECTION_2(nsFoo, mBar, mBaz)</code> in <code>nsFoo.cpp</code>.</li>
</ol>

<p>It is possible that your class has more complicated structure than this picture. For example, your class may have multiple <code>nsISupports</code> base classes, which requires the use of some <code>*_AMBIGUOUS</code> macros that perform a disambiguating downcast. Or your class may have a complicated ownership structure, such that the simple <code>NS_IMPL_CYCLE_COLLECTION_<em>N</em></code> macros are insufficient; in this case you might need to implement the <em>Traverse</em> and <em>Unlink</em> methods of your helper class manually. It's helpful even in these cases to use the <code>NS_IMPL_CYCLE_COLLECTION_TRAVERSE_{BEGIN,END}</code> and <code>NS_IMPL_CYCLE_COLLECTION_UNLINK_{BEGIN,END}</code> macros. You can see an example of their use in some more complicated classes such as <code>content/base/src/nsGenericElement.cpp</code>. If your class has tearoffs or is being aggregated by other classes it is important to make the tearoff classes or the outer classes participate in cycle collection too, not doing so could lead to the cycle collector trying to collect the objects too soon.</p>

<h3 id="Manually_implementing_the_Traverse_and_Unlink_methods">Manually implementing the Traverse and Unlink methods</h3>

<p>Each field that may contain cycle collected objects needs to be passed to the cycle collector, so it can detect cycles that pass through those fields.</p>

<p>The main macro for Traverse is NS_IMPL_CYCLE_COLLECTION_TRAVERSE:</p>

<p>  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSomeMember)</p>

<p>Unlink works similarly:</p>

<p>  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSomeMember)</p>

<p>These macros should handle a variety of cases, such as reference counted pointers to cycle collected nsISupports or non-nsISupports objects, as well as arrays of these pointers.</p>

<h3 id="Handling_JSObjects_fields">Handling  JSObjects fields</h3>

<p>If your class needs to store a pointer to a <code>JSObject</code> then you need to tell the cycle collector about it. The approach you should take is as follows.</p>

<p>Firstly it must be held in a<code> JS::Heap&lt;JSObject *&gt;</code> field.  For example, suppose your class nsFoo has field <code>mSomeObj</code>:</p>

<pre class="brush: cpp">private:
  ...
  JS::Heap&lt;JSObject*&gt; mSomeObj;
  ...</pre>

<p>When you have something in the JS object pointer you need to use <code>mozilla::HoldJSObjects</code> to tell the GC to <em>trace</em> it and keep the object alive:</p>

<pre class="brush: cpp">...
mSomeObj = ... ;
<code>mozilla::HoldJSObjects</code>(this);
...
</pre>

<p>In the Unlink method (or destructor) you need to set the object pointer to <code>NULL</code>:</p>

<pre class="brush: cpp">NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFoo)
  ...
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSomeMember)
  ...
  //if your class is a wrapper cache: 
  //NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER

  tmp-&gt;mSomeObj = nullptr;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
</pre>

<p>In the destructor, you should call</p>

<pre class="brush: cpp"><code>mozilla::DropJSObjects</code>(this);</pre>

<p>In your Traverse method you need to list members involved in the cycle collector, i-e no JS objects:</p>

<pre class="brush: cpp">NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFoo)
  ...
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSomeMember)
  ...
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
</pre>

<p>Finally, you need to manually add the JS object to the <em>Trace</em> method:</p>

<pre class="brush: cpp">NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsFoo)
  //if your class is a wrapper cache:
  //NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER

  NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mSomeObj)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
</pre>

<p>Note that if your class is a wrapper cache then you likely have generate code that uses <code>NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_#</code> macro instead of <code>NS_IMPL_CYCLE_COLLECTION_#</code>. Unfortunately this macro defines the Trace method and so you can't list your JS object; hence, you need to also manually implmenet Trace and Unlink as above.</p>

<h3 id="Handling_JSValue_fields">Handling JS::Value fields</h3>

<p>Recall (or see <a href="/en-US/docs/SpiderMonkey/JSAPI_Reference/Jsval" title="/en-US/docs/SpiderMonkey/JSAPI_Reference/Jsval">here</a>) that a <code>JS::Value</code> may reference a string or object and is subject to GC. Hence, we need to tell the cycle collector about any such member variables. This is the same as for the <code>JSObject</code> case, but using the <code>NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK</code> macro:</p>

<pre class="brush: cpp">NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsFoo)
  ...
  NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK(mSomeJSVal).
  ...
NS_IMPL_CYCLE_COLLECTION_TRACE_END</pre></div><div id="footer"><hr/><p>This page was originally written for <a href="https://developer.mozilla.org">developer.mozilla.org</a> and is used here under the <a href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike license</a> (CC-BY-SA).</p>
<p>Original contributors to this page: <a href="https://developer.mozilla.org/en-US/profiles/wbamberg">wbamberg</a>, <a href="https://developer.mozilla.org/en-US/profiles/mdnwebdocs-bot">mdnwebdocs-bot</a>, <a href="https://developer.mozilla.org/en-US/profiles/SphinxKnight">SphinxKnight</a>, <a href="https://developer.mozilla.org/en-US/profiles/jonco">jonco</a>, <a href="https://developer.mozilla.org/en-US/profiles/nbp">nbp</a>, <a href="https://developer.mozilla.org/en-US/profiles/teoli">teoli</a>, <a href="https://developer.mozilla.org/en-US/profiles/amccreight">amccreight</a>, <a href="https://developer.mozilla.org/en-US/profiles/deian">deian</a>, <a href="https://developer.mozilla.org/en-US/profiles/mikeaich">mikeaich</a>, <a href="https://developer.mozilla.org/en-US/profiles/zhangpin04">zhangpin04</a>, <a href="https://developer.mozilla.org/en-US/profiles/jlebar">jlebar</a>, <a href="https://developer.mozilla.org/en-US/profiles/Hsivonen">Hsivonen</a>, <a href="https://developer.mozilla.org/en-US/profiles/Dougt">Dougt</a>, <a href="https://developer.mozilla.org/en-US/profiles/Mgjbot">Mgjbot</a>, <a href="https://developer.mozilla.org/en-US/profiles/Marsf">Marsf</a>, <a href="https://developer.mozilla.org/en-US/profiles/Nickolay">Nickolay</a>, <a href="https://developer.mozilla.org/en-US/profiles/Sheppy">Sheppy</a>.</p></div></body>
</html>
