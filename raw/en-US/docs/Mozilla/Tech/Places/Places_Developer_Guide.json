{
    "content": "<p> This document is for extension and application developers who want to use the bookmarks and history APIs in Firefox 3. It provides code samples for many common use-cases, such as CRUD operations, searching, and observing.</p>\n<h2 id=\"Overview\" name=\"Overview\">Overview</h2>\n<p><a href=\"/en-US/docs/Places\" title=\"en/Places\">Places</a> is the umbrella term for a set of APIs for managing browsing history and URI metadata first introduced in Firefox 3. It encompasses history, bookmarks, tags, favicons, and annotations. There are two models of identity in the system: URIs, and unique integer identifiers for items in the bookmark system. Some of the APIs are URI-centric, some use item ids. The API signature and context usually make clear which is required.</p>\n<h2 id=\"Bookmarks\" name=\"Bookmarks\">Bookmarks</h2>\n<p>The toolkit bookmarks service is <a href=\"https://dxr.mozilla.org/mozilla-central/source/toolkit/components/places/public/nsINavBookmarksService.idl\" rel=\"custom\">nsINavBookmarksService</a>:</p>\n<pre class=\"brush: js\">var bookmarks = Cc[\"@mozilla.org/browser/nav-bookmarks-service;1\"]\n                .getService(Ci.nsINavBookmarksService);\n</pre>\n<p>This service provides methods for adding, editing and deleting items in the bookmarks collection.</p>\n<h3 id=\"Types\" name=\"Types\">Types in the Bookmark System</h3>\n<p>There are the four types of items in the bookmarks system, and their identifiers in the IDL:</p>\n<ul>\n  <li>Bookmark: nsINavBookmarksService.TYPE_BOOKMARK</li>\n  <li>Folder: nsINavBookmarksService.TYPE_FOLDER</li>\n  <li>Separator: nsINavBookmarksService.TYPE_SEPARATOR</li>\n  <li>Dynamic Container: nsINavBookmarksService.TYPE_DYNAMIC_CONTAINER</li>\n</ul>\n<h3 id=\"Identification\" name=\"Identification\">Identifying Items in the Bookmark System</h3>\n<p>Items in the bookmarks collection are identified by an id unique to the user's profile. Most of the APIs provided by the bookmarks service use an item's id to identify what to act on.</p>\n<p>The bookmarks datastore is hierarchical, modeling folders and their contents. The ids of several significant folders are made available as attributes of <code><a href=\"/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsINavBookmarksService\" title=\"\">nsINavBookmarksService</a></code>.</p>\n<ul>\n  <li>nsINavBookmarksService.placesRoot - The root folder of hierarchy.</li>\n  <li>nsINavBookmarksService.bookmarksMenuFolder - The contents of this folder are visible in the Bookmarks menu.</li>\n  <li>nsINavBookmarksService.toolbarFolder - The contents of this folder are visible on the Bookmarks toolbar.</li>\n  <li>nsINavBookmarksService.unfiledBookmarksFolder - Items that have been \"starred\", but not places in any folder.</li>\n  <li>nsINavBookmarksService.tagsFolder - Subfolders of this folder are tags, and their children are URIs that have been tagged with that folder's name.</li>\n</ul>\n<h3 id=\"Other_Bookmarks_APIs\" name=\"Other_Bookmarks_APIs\">Other Bookmarks APIs</h3>\n<p>Note: This document covers the toolkit Places services. However, Firefox developers can take advantage of several helper APIs that are browser-specific:</p>\n<ul>\n  <li><a href=\"/en-US/docs/Toolkit_API/FUEL\" title=\"en/FUEL\">FUEL</a> - A collection of wrapper APIs for easing access to a number of Firefox utilities and services</li>\n  <li><a href=\"https://dxr.mozilla.org/mozilla-central/source/browser/components/places/public/nsIPlacesTransactionsService.idl\" rel=\"custom\">nsIPlacesTransactionsService</a> - A Firefox service for modifying bookmarks in a transactional manner, providing facilities for undo/redo</li>\n  <li><a href=\"/en-US/docs/Places_utilities_for_JavaScript\" title=\"en/Places_utilities_for_JavaScript\">Places utilities for JavaScript</a> - Accessors and helper functions for Firefox and extensions</li>\n</ul>\n<h3 id=\"Creating\" name=\"Creating\">Creating Bookmarks, Folders and Other Items</h3>\n<p>Creating a Bookmark</p>\n<pre class=\"brush: js\">// create an nsIURI for the URL to be bookmarked.\nvar bookmarkURI = Cc[\"@mozilla.org/network/io-service;1\"]\n                  .getService(Ci.nsIIOService)\n                  .newURI(\"http://www.mozilla.com\", null, null);\n\nvar bookmarkId = bookmarks.insertBookmark(\n  bookmarks.toolbarFolder, // The id of the folder the bookmark will be placed in.\n  bookmarkURI,             // The URI of the bookmark - an nsIURI object.\n  bookmarks.DEFAULT_INDEX, // The position of the bookmark in its parent folder.\n  \"my bookmark title\");    // The title of the bookmark.\n</pre>\n<p>Creating a Folder</p>\n<pre class=\"brush: js\">var folderId = bookmarks.createFolder(\n  bookmarks.toolbarFolder, // The id of the folder the new folder will be placed in.\n  \"my folder title\",       // The title of the new folder.\n  bookmarks.DEFAULT_INDEX);    // The position of the new folder in its parent folder.\n</pre>\n<p>Creating a Separator</p>\n<pre class=\"brush: js\">var separatorId = bookmarks.insertSeparator(\n  bookmarks.toolbarFolder, // The id of the folder the separator will be placed in.\n  bookmarks.DEFAULT_INDEX);    // The position of the separator in its parent folder.\n</pre>\n<p>Creating a Livemark</p>\n<pre class=\"brush: js\">var IOService = Cc[\"@mozilla.org/network/io-service;1\"]\n                .getService(Ci.nsIIOService);\n\nvar siteURI = IOService.newURI(\"http://www.mozilla.com\", null, null);\nvar feedURI = IOService.newURI(\"http://www.mozilla.org/news.rdf\", null, null);\n\nvar livemarks = Cc[\"@mozilla.org/browser/livemark-service;2\"]\n                .getService(Ci.nsILivemarkService);\n\nlivemarks.createLivemark(bookmarks.toolbarFolder, // The id of the folder the livemark will be placed in\n  \"My Livemark Title\",        // The title of the livemark\n  siteURI,                    // The URI of the site. A nsIURI object.\n  feedURI,                    // The URI of the actual feed. A nsIURI object.\n  bookmarks.DEFAULT_INDEX);   // The position of the livemark in its parent folder.\n</pre>\n<h3 id=\"Reading\" name=\"Reading\">Accessing Bookmarks and Related Items</h3>\n<h4 id=\"Item_Properties\" name=\"Item_Properties\">Accessing Item Properties</h4>\n<p>For all items:</p>\n<ul>\n  <li>String getItemTitle(aItemId) - Returns an item's title</li>\n  <li>Int64 getItemIndex(aItemId) - Returns an item's position in it's parent folder</li>\n  <li>PRTime getItemType(aItemId) - Returns the type of an item (bookmark, folder, separator)</li>\n  <li>PRTime getItemDateAdded(aItemId) - Returns the time in microseconds that an item was added</li>\n  <li>PRTime getItemLastModified(aItemId) - Returns the time in microseconds that an item was last modified</li>\n  <li>Int64 getFolderIdForItem(aItemId) - Returns the id of the folder containing the given item.</li>\n  <li>String getItemGUID(aItemId) <span class=\"inlineIndicator obsolete obsoleteInline\" title=\"(Firefox 14.0 / Thunderbird 14.0 / SeaMonkey 2.11)\">Obsolete since Gecko 14.0</span> - Returns a globally unique identifier for the item. This is mainly for use by extensions that sync bookmark data between different profiles.</li>\n</ul>\n<p>For bookmarks:</p>\n<ul>\n  <li>nsIURI getBookmarkURI(aItemId) - Returns the URI of a bookmark item</li>\n  <li>String getKeywordForBookmark(aItemId) - Returns a bookmark's keyword, or null</li>\n</ul>\n<p>For folders:</p>\n<ul>\n  <li>Int64 getChildFolder(aFolderId, aSubfolderTitle) - Returns the id of the first subfolder matching the given title.</li>\n  <li>Int64 getIdForItemAt(aFolderId, aPosition) - Returns the id of the item at the given position (throws if there's no item there).</li>\n  <li>Bool getFolderReadonly(aFolderId)</li>\n</ul>\n<h4 id=\"Folder_Contents\" name=\"Folder_Contents\">Accessing Folder Contents</h4>\n<p>Queries in Places are executed through the main history service. The example below shows how to enumerate a bookmark folder's contents, and how to access the properties of the items themselves.</p>\n<pre class=\"brush: js\">var history = Cc[\"@mozilla.org/browser/nav-history-service;1\"]\n\t .getService(Ci.nsINavHistoryService);\nvar query = history.getNewQuery();\nquery.setFolders([myFolderId], 1);\nvar result = history.executeQuery(query, history.getNewQueryOptions());\n// The root property of a query result is an object representing the folder you specified above.\nvar folderNode = result.root;\n// Open the folder, and iterate over its contents.\nfolderNode.containerOpen = true;\nfor (var i=0; i &lt; folderNode.childCount; ++i) {\n\tvar childNode = folderNode.getChild(i);\n\t // Some item properties.\n\tvar title = childNode.title;\n\tvar id = childNode.itemId;\n\tvar type = childNode.type;\n\n\t// Some type-specific actions.\n\tif (type == Ci.nsINavHistoryResultNode.RESULT_TYPE_URI) {\n\t\tvar uri = childNode.uri;\n\t}\n\telse if (type == Ci.nsINavHistoryResultNode.RESULT_TYPE_FOLDER) {\n\t\tchildNode.QueryInterface(Ci.nsINavHistoryContainerResultNode);\n\t\tchildNode.containerOpen = true;\n\t\t// now you can iterate over a subfolder's children\n\t}\n}\n</pre>\n<p>ther available node types are documented in the <a class=\"external\" href=\"http://mxr.mozilla.org/seamonkey/source/toolkit/components/places/public/nsINavHistoryService.idl\">IDL</a>.</p>\n<h4 id=\"Searching\" name=\"Searching\">Searching Bookmarks</h4>\n<p>Queries are executed through the history service. The example below shows how to search through all bookmarks, and to iterate over the results.</p>\n<pre class=\"brush: js\">var bookmarks = Cc[\"@mozilla.org/browser/nav-bookmarks-service;1\"]\n                .getService(Ci.nsINavBookmarksService);\nvar history = Cc[\"@mozilla.org/browser/nav-history-service;1\"]\n              .getService(Ci.nsINavHistoryService);\n\nvar query = history.getNewQuery();\n\n// Specify folders to be searched\nvar folders = [bookmarks.toolbarFolder, bookmarks.bookmarksMenuFolder,\n               bookmarks.unfiledBookmarksFolder];\nquery.setFolders(folders, folders.length);\n\n// Specify terms to search for, matches against title, URL and tags\nquery.searchTerms = \"firefox\";\n\nvar options = history.getNewQueryOptions();\noptions.queryType = options.QUERY_TYPE_BOOKMARKS;\n\nvar result = history.executeQuery(query, options);\n\n// The root property of a query result is an object representing the folder you specified above.\nvar resultContainerNode = result.root;\n\n// Open the folder, and iterate over its contents.\nresultContainerNode.containerOpen = true;\nfor (var i=0; i &lt; resultContainerNode.childCount; ++i) {\n  var childNode = resultContainerNode.getChild(i);\n\n  // Accessing properties of matching bookmarks\n  var title = childNode.title;\n  var uri = childNode.uri;\n}\n</pre>\n<h3 id=\"Updating\" name=\"Updating\">Updating Bookmark Items</h3>\n<p>For all items:</p>\n<ul>\n  <li>setItemTitle(aItemId, aTitle) - Changes an item's title.</li>\n  <li>setItemIndex(aItemId, aIndex) - Changes an item's position. NOTE: This does not re-index the whole folder - use moveItem for a managed solution.</li>\n  <li>setItemDateAdded(aItemId, aDateAdded) - Set the date the item was first added, in microseconds.</li>\n  <li>setItemLastModified(aItemId, aLastModified) - Set the date the item was last modified, in microseconds.</li>\n  <li>setItemGUID(aItemId, aGUID) <span class=\"inlineIndicator obsolete obsoleteInline\" title=\"(Firefox 14.0 / Thunderbird 14.0 / SeaMonkey 2.11)\">Obsolete since Gecko 14.0</span> - Returns a globally unique identifier for the item. This is mainly for use by extensions that sync bookmark data between different profiles.</li>\n  <li>moveItem (aFolderId, aNewParentId, aIndex) - Move an item from one folder to another.</li>\n</ul>\n<p>For bookmarks:</p>\n<ul>\n  <li>changeBookmarkURI(aItemId, aURI) - Change a bookmark's URI.</li>\n  <li>setKeywordForBookmark(aItemId, aKeyword) - Set the keyword for a bookmark.</li>\n</ul>\n<h3 id=\"Deleting\" name=\"Deleting\">Deleting Bookmark Items</h3>\n<p>With the bookmarks service:</p>\n<ul>\n  <li>removeItem(aItemId) - Works for all types</li>\n  <li>removeFolder(aItemId) - Works for folders and livemarks</li>\n  <li>removeFolderChildren(aItemId) - Works for folders and livemarks</li>\n</ul>\n<h3 id=\"Observing\" name=\"Observing\">Observing Bookmark Events</h3>\n<p>The <code>nsINavBookmarkObserver</code> interface is used for observing bookmarks activity such as item additions, changes and deletions.</p>\n<pre class=\"brush: js\">// Create a bookmark observer\nvar observer = {\n  onBeginUpdateBatch: function() {\n    // This method is notified when a batch of changes are about to occur.\n    // Observers can use this to suspend updates to the user-interface, for example\n    // while a batch change is occurring.\n  },\n  onEndUpdateBatch: function() {\n    this._inBatch = false;\n  },\n  onItemAdded: function(id, folder, index) {\n  },\n  onItemRemoved: function(id, folder, index) {\n  },\n  onItemChanged: function(id, property, isAnnotationProperty, value) {\n    // isAnnotationProperty is a boolean value that is true of the changed property is an annotation.\n    // You can access a bookmark item's annotations with the &lt;code&gt;nsIAnnotationService&lt;/code&gt;.\n  },\n  onItemVisited: function(id, visitID, time) {\n    // The visit id can be used with the History service to access other properties of the visit.\n    // The time is the time at which the visit occurred, in microseconds.\n  },\n  onItemMoved: function(id, oldParent, oldIndex, newParent, newIndex) {\n    // oldParent and newParent are the ids of the old and new parent folders of the moved item.\n  },\n  QueryInterface: function(iid) {\n    if (iid.equals(Ci.nsINavBookmarkObserver) ||\n        iid.equals(Ci.nsISupports)) {\n      return this;\n    }\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  },\n};\n\n// Register the observer with the bookmarks service\nvar bmsvc = Cc[\"@mozilla.org/browser/nav-bookmarks-service;1\"]\n            .getService(Ci.nsINavBookmarksService);\nbmsvc.addObserver(observer, false);\n\n// Un-register the observer when done.\nbmsvc.removeObserver(observer);\n\n</pre>\n<h3 id=\"HTML_Import.2FExport\" name=\"HTML_Import.2FExport\">HTML Import/Export</h3>\n<p>The <code>nsIPlacesImportExportService</code> service is used for import and export of bookmarks in the <a class=\"external\" href=\"http://msdn.microsoft.com/en-us/library/aa753582(VS.85).aspx\">Netscape Bookmarks HTML</a> format. Note that this service is only currently available for Firefox, not other toolkit-based applications.</p>\n<p>Importing:</p>\n<ul>\n  <li>importHTMLFromFile (nsILocalFile aFile, boolean aIsInitialImport) - This imports all the bookmarks in the specified file into the current bookmarks collection. If aIsInitialImport is true, all pre-existing bookmarks in the toolbar and menu folders will be deleted.</li>\n</ul>\n<div class=\"note\">\n  <strong>Note:</strong> The method <code>importHTMLFromFileToFolder()</code> method was removed in Gecko 14.0 (Firefox 14.0 / Thunderbird 14.0 / SeaMonkey 2.11).</div>\n<p>Exporting:</p>\n<ul>\n  <li>exportHTMLToFile (nsILocalFile aFile) - This exports all bookmarks in the toolbar, menu and unfiled bookmarks folders into the specified file.</li>\n</ul>\n<h3 id=\"Backup.2FRestore\" name=\"Backup.2FRestore\">Backup/Restore</h3>\n<p>The new bookmarks system uses the JSON format for storing backups of users' bookmarks. The APIs are available via the PlacesUtils API in the utils.js Javascript module.</p>\n<pre class=\"brush: js\">var Ci = Components.interfaces;\nvar Cc = Components.classes;\nvar Cu = Components.utils;\n \n// Import PlacesUtils\nCu.import(\"resource://gre/modules/PlacesUtils.jsm\");\nCu.import(\"resource://gre/modules/Services.jsm\");\n \n// Create the backup file\nvar jsonFile = Services.dirsvc.get(\"ProfD\", Ci.nsILocalFile);\njsonFile.append(\"bookmarks.json\");\njsonFile.create(Ci.nsILocalFile.NORMAL_FILE_TYPE, 0600);\n \n// Export bookmarks in JSON format to file\nPlacesUtils.backupBookmarksToFile(jsonFile);\n \n// Restore bookmarks from the JSON file\n// NOTE: This *overwrites* all pre-existing bookmarks\nPlacesUtils.restoreBookmarksFromJSONFile(jsonFile);\n</pre>\n<h2 id=\"History\" name=\"History\">History</h2>\n<p>The toolkit history service is <a href=\"https://dxr.mozilla.org/mozilla-central/source/toolkit/components/places/public/nsINavHistoryService.idl\" rel=\"custom\">nsINavHistoryService</a>:</p>\n<pre class=\"brush: js\">var history = Cc[\"@mozilla.org/browser/nav-history-service;1\"]\n              .getService(Ci.nsINavHistoryService);\n\n</pre>\n<p>The history service provides methods for adding, editing, deleting browser history. It's also the jump-off point for querying and searching the history and bookmarks collections.</p>\n<p>While nsINavHistory is the main interface for history, there are a couple of other interfaces available for legacy and context-specific uses:</p>\n<ul>\n  <li><code>nsIBrowserHistory</code> - Detailed page addition and removal methods</li>\n  <li><code>nsIGlobalHistory2</code> - Simple page detection and addition</li>\n  <li><code>nsIGlobalHistory3</code> - For adding document redirects</li>\n</ul>\n<h3 id=\"Adding\" name=\"Adding\">Adding to History</h3>\n<p>Places provides a couple of interfaces for adding to, and editing the browsing history. The main interface is nsINavHistoryService. Other interfaces that provide specialized abilities are nsIBrowserHistory and nsIGlobalHistory. Examples of the capabilities of each are provided below.</p>\n<pre class=\"brush: js\">// Places deals in URIs, so here's a helper for creating them.\nfunction uri(spec) {\n  return Cc[\"@mozilla.org/network/io-service;1\"].\n         getService(Ci.nsIIOService).\n         newURI(spec, null, null);\n}\n\n// Adding a basic visit via the core Places history service.\nvar history = Cc[\"@mozilla.org/browser/nav-history-service;1\"].\n              getService(Ci.nsINavHistoryService);  \nvar ourURI = uri(\"http://www.mozilla.com\");\nvar visitDate = Date.now() * 1000; // in microseconds\nvar referrerURI = null; // or a URI\nvar isRedirect = false;\nvar visitType = history.TRANSITION_LINK; // the visit is from a link that was clicked\nvar sessionId = 0; // can link the visit with a specific browsing session\nhistory.addVisit(ourURI, visitDate, referrerURI,\n                 visitType, isRedirect, sessionId);\n\n// Add a visit to a URL, with a page title and visited time\n// via nsIBrowserHistory.\nvar browserHistory = histsvc.QueryInterface(Ci.nsIBrowserHistory);\nvar ourURI = uri(\"http://www.mozilla.com\");\nvar pageTitle = \"Mozilla\";\nvar visitDate = Date.now() * 1000; // in microseconds\nbrowserHistory.addPageWithDetails(ourURI, \"Mozilla\", visitDate);\n\n// Add a visit to a URL, with extended behavior information\n// via nsIGlobalHistory3.\nvar globalHistory = Cc[\"@mozilla.org/browser/global-history;2\"].\n                    getService(Ci.nsIGlobalHistory2);\nvar ourURI = uri(\"http://www.mozilla.com\");\nvar isRedirect = false;\nvar isTopLevel = true;\nglobalHistory.addURI(ourURI, isRedirect, isTopLevel, referrerURI);\nglobalHistory.setPageTitle(ourURI, \"Mozilla\");\n</pre>\n<h3 id=\"Deleting_2\" name=\"Deleting_2\">Deleting from History</h3>\n<pre class=\"brush: js\">// Places deals in URIs, so here's a helper for creating them.\nfunction uri(spec) {\n  return Cc[\"@mozilla.org/network/io-service;1\"].\n         getService(Ci.nsIIOService).\n         newURI(spec, null, null);\n}\n\nvar browserHistory = histsvc.QueryInterface(Ci.nsIBrowserHistory);\nvar ourURI = uri(\"http://www.mozilla.com\");\n\n// Remove all visits for a single URL from history\nbrowserHistory.removePage(ourURI);\n\n// Remove all visits for multiple URLs from history\nvar urisToDelete = [ourURI];\n// will call nsINavHistoryObserver.onBeginUpdateBatch/onEndUpdateBatch\nvar doNotify = false;\nbrowserHistory.removePages(urisToDelete, urisToDelete.length, doNotify);\n\n// Remove all visits within a given time period\nvar endDate = Date.now() * 1000; // now, in microseconds\nvar startDate = endDate - (7 * 86400 * 1000 * 1000); // one week ago, in microseconds\nbrowserHistory.removePagesByTimeframe(startDate, endDate);\n\n// Remove all pages for a given host\nvar entireDomain = true; // will delete from all hosts from the given domain\nbrowserHistory.removePagesFromHost(\"mozilla.com\", true);\n// Remove all history visits\nbrowserHistory.removeAllPages();</pre>\n<h3 id=\"Querying\" name=\"Querying\">Querying History</h3>\n<p>The code sample below queries the browser history for the ten most visited URLs in the browser history.</p>\n<pre class=\"brush: js\">var historyService = Components.classes[\"@mozilla.org/browser/nav-history-service;1\"]\n                               .getService(Components.interfaces.nsINavHistoryService);\nvar query = historyService.getNewQuery();\nvar options = historyService.getNewQueryOptions();\noptions.sortingMode = options.SORT_BY_VISITCOUNT_DESCENDING;\noptions.maxResults = 10;\n\n// execute the query\nvar result = historyService.executeQuery(query, options);\n\n// iterate over the results\nresult.root.containerOpen = true;\nvar count = result.root.childCount;\nfor (var i = 0; i &lt; count; i++) {\n  var node = result.root.getChild(i);\n  // do something with the node properties...\n  var title = node.title;\n  var url = node.uri;\n  var visited = node.accessCount;\n  var lastVisitedTimeInMicrosecs = node.time;\n  var iconURI = node.icon; // is null if no favicon available\n}\n\nresult.root.containerOpen = false;\n</pre>\n<h3 id=\"Querying_for_redirects_and_from_visit\" name=\"Querying_for_redirects_and_from_visit\">Querying History for redirects and from_visit</h3>\n<p>Results of type <code>RESULT_TYPE_FULL_VISIT</code> have information about the visit, such as the referring visit, and how the transition happened (typed, redirect, link, etc). The problem is that it is <strong>not yet implemented</strong> -- see <span class=\"lang lang-*\"><a class=\"link-https\" href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=320831\" rel=\"external nofollow\" title=\"https://bugzilla.mozilla.org/show_bug.cgi?id=320831\">bug 320831</a></span>. So the only solution for now seems to do one own SQL queries to the <a class=\"external\" href=\"http://www.forensicswiki.org/wiki/Mozilla_Firefox_3_History_File_Format\"><code>Places</code> database</a>.</p>\n<p>Here is how one can get a connection to the Places database:</p>\n<pre class=\"brush: js\">function getPlacesDbConn() {\n    return Components.classes['@mozilla.org/browser/nav-history-service;1'].\n      getService(Components.interfaces.nsPIPlacesDatabase).DBConnection;\n}\n</pre>\n<p>And then to get the a redirected visit_id from another visit_id:</p>\n<pre class=\"brush: js\">function getFromVisit(visit_id) {\n  var sql = &lt;cdata&gt;&lt;![CDATA[\n    SELECT from_visit FROM moz_places, moz_historyvisits\n    WHERE moz_historyvisits.id = :visit_id AND moz_places.id = moz_historyvisits.place_id;\n  ]]&gt;&lt;/cdata&gt;.toString();\n  var sql_stmt = getPlacesDbConn.createStatement(sql);\n  sql_stmt<span>.params.visit_id = visit_id;  </span>\n\n  var from_visit;\n  try {\n    // Here we can't use the \"executeAsync\" method since have to return a\n    // result right-away.\n    while (sql_stmt.executeStep()) {\n      from_visit = sql_stmt.row.from_visit;\n    }\n  } finally {\n    sql_stmt.reset();\n  }\n  return from_visit;\n}\n</pre>\n<div class=\"note\">\n  <strong>Note:</strong> The <code>&lt;cdata&gt;&lt;![CDATA[ xxx ]]&gt;&lt;/cdata&gt;.toString()</code> notation is E4X and it makes possible to write multi-line strings in JavaScript. This is very useful when writing long SQL statements.</div>\n<h3 id=\"Searching_2\" name=\"Searching_2\">Searching History</h3>\n<p>Queries are executed through the history service. The example below shows how to search through browser history, and to iterate over the results.</p>\n<pre class=\"brush: js\">var history = Cc[\"@mozilla.org/browser/nav-history-service;1\"]\n              .getService(Ci.nsINavHistoryService);\n\nvar query = history.getNewQuery();\n\n// Specify terms to search for, matches against title and URL\nquery.searchTerms = \"firefox\";\n\nvar result = history.executeQuery(query, history.getNewQueryOptions());\n\n// The root property of a query result is an object representing the folder you specified above.\nvar resultContainerNode = result.root;\n\n// Open the result, and iterate over it's contents.\nresultContainerNode.containerOpen = true;\nfor (var i=0; i &lt; resultContainerNode.childCount; ++i) {\n  var childNode = resultContainerNode.getChild(i);\n\n  // Accessing properties of matching bookmarks\n  var title = childNode.title;\n  var uri = childNode.uri;\n}\n</pre>\n<h3 id=\"Observing_2\" name=\"Observing_2\">Observing History</h3>\n<p>The nsINavHistoryObserver interface allows observation of history events such as new visits, page title changes, page expiration and when all history is cleared.</p>\n<pre class=\"brush: js\">var history = Cc[\"@mozilla.org/browser/nav-history-service;1\"].\n              getService(Ci.nsINavHistoryService);\nlet observer = {\n  onBeginUpdateBatch: function() {\n  },\n  onEndUpdateBatch: function() {\n  },\n  onVisit: function(aURI, aVisitID, aTime, aSessionID, aReferringID, aTransitionType) {\n  },\n  onTitleChanged: function(aURI, aPageTitle) {\n  },\n  onDeleteURI: function(aURI) {\n  },\n  onClearHistory: function() {\n  },\n  onPageChanged: function(aURI, aWhat, aValue) {\n  },\n  onPageExpired: function(aURI, aVisitTime, aWholeEntry) {\n  },\n  QueryInterface: function(iid) {\n    if (iid.equals(Components.interfaces.nsINavHistoryObserver) ||\n        iid.equals(Components.interfaces.nsISupports)) {\n      return this;\n    }\n    throw Cr.NS_ERROR_NO_INTERFACE;\n  }\n};\n\nhistory.addObserver(observer, false);\n</pre>\n<h2 id=\"New\" name=\"New\">New</h2>\n<h3 id=\"Tags\" name=\"Tags\">Tagging Service</h3>\n<p>The tagging of URIs is provided by <code>nsITaggingService</code>. The service is URI-centric, meaning that consumers can tag URIs directly, without first creating a bookmark. The unique identifier is the URI, and all APIs require URIs as <code>nsIURI</code> objects.</p>\n<pre class=\"brush: js\">// Get the tagging service\nvar tagssvc = Cc[\"@mozilla.org/browser/tagging-service;1\"]\n              .getService(Ci.nsITaggingService);\n\n// Create a URI to tag\nvar IOService = Cc[\"@mozilla.org/network/io-service;1\"]\n                .getService(Ci.nsIIOService);\nvar myURI = IOService.newURI(\"http://www.mozilla.com\", null, null);\n\n// Tag the URI\ntagssvc.tagURI(myURI, [\"mozilla\", \"firefox\"]);\n\n// Get an array of tags for a URI\nvar myTags = tagssvc.getTagsForURI(myURI, {});\n\n// Get an array of URIs for a tag\nvar taggedURIs = tagssvc.getURIsForTag(\"mozilla\");\n\n// Get an array of all tags\nvar arrayOfAllTags = tagssvc.allTags;\n\n// Remove tags from a URI\ntagssvc.untagURI(myURI, [\"mozilla\", \"firefox\"]);\n</pre>\n<p><br>\n  This service currently integrates with and is internally dependent upon bookmarks:</p>\n<ul>\n  <li>If you tag a URI that is not previously bookmarked, a new bookmark is created in the Unfiled Bookmarks folder.</li>\n  <li>If you delete a bookmark, each tag is removed from it, deleted from the tag data collection. For example, if you delete all your bookmarks, all your tags will also be deleted.</li>\n  <li>If you delete your places.sqlite file, all tags will be deleted (along with all history and bookmarks).</li>\n</ul>\n<h3 id=\"Annotations\" name=\"Annotations\">Annotations</h3>\n<p>Annotations provide a way to store small bits of arbitrary data for a URI or a bookmark:</p>\n<pre class=\"brush: js\">// Get the annotation service\nvar annotations = Cc[\"@mozilla.org/browser/annotation-service;1\"]\n                  .getService(Ci.nsIAnnotationService);\n\n// Create a URI to annotate\nvar IOService = Cc[\"@mozilla.org/network/io-service;1\"]\n                .getService(Ci.nsIIOService);\nvar myURI = IOService.newURI(\"http://www.mozilla.com\", null, null);\n\n// Add an annotation to the URI, that expires when the URI is deleted\n// or expires from the browser history\nannotations.setPageAnnotation(myURI, \"myAnnotation\", \"notes for this URI...\",\n                              0, annotations.EXPIRE_WITH_HISTORY);\n\n// Create a bookmark to annotate\nvar bookmarks = Cc[\"@mozilla.org/browser/nav-bookmarks-service;1\"]\n                .getService(Ci.nsINavBookmarksService);\nvar myBookmark = bookmarks.insertBookmark(bookmarks.toolbarFolder, myURI,\n                                          bookmarks.DEFAULT_INDEX, \"my bookmark\");\n\n// Add an annotation to the bookmark, that expires only when\n// the bookmark is deleted\nannotations.setItemAnnotation(myBookmark, \"myAnnotation\", \"notes for this bookmark...\",\n                              0, annotations.EXPIRE_WITH_HISTORY);\n</pre>\n<p>Note the syntactic difference between the URI and bookmark annotation APIs: URI annotation APIs use \"Page\" in method names whereas bookmark annotation APIs use \"Item\" in method names.</p>\n<h3 id=\"Saved_Searches\" name=\"Saved_Searches\">Saved Searches</h3>\n<p>New in Firefox 3 is the ability to save searches of bookmarks or history. These saved searches appear as folders in your bookmarks, with a special icon to signify their difference from normal folders. The contents of these folders are updated when expanded, executing the search against the current history and bookmarks collections.</p>\n<p>Saved searches can be formulated as URIs, and added to the bookmarks collection as a normal bookmark. Formulation of search URIs is documented <a class=\"external\" href=\"/en-US/docs/docs/Places_query_URIs\" title=\"en/docs/Places_query_URIs\">here</a>.</p>\n<pre class=\"brush: js\">// Formulate a URI to query for the 10 most visited URIs in the browser history\nvar mostVisited = \"place:queryType=0&amp;sort=8&amp;maxResults=10\";\n\n// Create an nsIURI for the URL to be bookmarked.\nvar bookmarkURI = Cc[\"@mozilla.org/network/io-service;1\"]\n                  .getService(Ci.nsIIOService)\n                  .newURI(mostVisited, null, null);\n\n// Add the search to the bookmarks toolbar\nvar id = bookmarks.insertBookmark(bookmarks.toolbarFolder, bookmarkURI,\n                                  bookmarks.DEFAULT_INDEX, \"Most Visited\");<span style=\"line-height: 18px; white-space: normal;\">\n</span></pre>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>",
    "title": "Places Developer Guide"
}