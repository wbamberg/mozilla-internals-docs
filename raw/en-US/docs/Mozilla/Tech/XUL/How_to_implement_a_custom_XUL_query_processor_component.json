{
    "content": "<p>XUL supports templating to create a block of content from a datasource query. The <a href=\"en/XUL/Template_Guide\"> XUL Template Guide</a> has lots of detailed information on using XUL templates. XUL provides template query processors for RDF, XML and SQL (<a href=\"en/Storage\">mozStorage</a>). The templating system also supports building custom query processors. Custom query processors are XPCOM components, must implement the <code><a href=\"/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIXULTemplateQueryProcessor\" title=\"\">nsIXULTemplateQueryProcessor</a></code> interface and follow some conventions for when registering the component.</p>\n\n<p>In this example, we will create a simple <a href=\"en/How_to_Build_an_XPCOM_Component_in_Javascript\"> JavaScript XPCOM component</a>. The component will hold a small array of JavaScript objects as its datasource. In practice, you would use your own custom source of data.</p>\n\n<p>Here is an example of what our XUL might look like when using a custom query processor:</p>\n\n<pre>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-stylesheet href=\"chrome://global/skin/\" type=\"text/css\"?&gt;\n&lt;window xmlns=\"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\"&gt;\n    &lt;grid&gt;\n        &lt;columns&gt;\n            &lt;column flex=\"1\"/&gt;\n            &lt;column flex=\"3\"/&gt;\n            &lt;column flex=\"2\"/&gt;\n            &lt;column flex=\"1\"/&gt;\n        &lt;/columns&gt;\n\n        &lt;rows datasources=\"dummy\" ref=\".\" querytype=\"simpledata\"&gt;\n            &lt;template&gt;\n                &lt;row uri=\"?\"&gt;\n                    &lt;label value=\"?name\"/&gt;\n                    &lt;label value=\"?age\"/&gt;\n                    &lt;label value=\"?hair\"/&gt;\n                    &lt;label value=\"?eye\"/&gt;\n                &lt;/row&gt;\n            &lt;/template&gt;\n        &lt;/rows&gt;\n    &lt;/grid&gt;\n&lt;/window&gt;\n</pre>\n\n<p>A few things to note. We are not really using the <code>datasources</code> in our sample component, so we set it to a dummy value. An empty string would be ok too. The <code>querytype</code> is important. It is used to create an instance of our XPCOM object. The contract id of our XPCOM component should be of the form <code>\"@mozilla.org/xul/xul-query-processor;1?name=xxx\"</code>, where the <strong>xxx</strong> is the <code>querytype</code> used in the XUL template block.</p>\n\n<p>Here is our sample JavaScript XPCOM query processor:</p>\n\n<pre>Components.utils.import(\"resource://gre/modules/XPCOMUtils.jsm\");\n\n\n// basic wrapper for nsIXULTemplateResult\nfunction TemplateResult(aData) {\n  this._data = aData;\n  // just make a random number for the id\n  this._id = Math.random(100000).toString();\n}\n\nTemplateResult.prototype = {\n  QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsIXULTemplateResult]),\n\n  // private storage\n  _data: null,\n\n  // right now our results are flat lists, so no containing/recursion take place\n  isContainer: false,\n  isEmpty: true,\n  mayProcessChildren: false,\n  resource: null,\n  type: \"simple-item\",\n\n  get id() {\n    return this._id;\n  },\n\n  // return the value of that bound variable such as ?name\n  getBindingFor: function(aVar) {\n    // strip off the ? from the beginning of the name\n    var name = aVar.toString().slice(1);\n    return this._data[name];\n  },\n\n  // return an object instead of a string for convenient comparison purposes\n  // or null to say just use string value\n  getBindingObjectFor: function(aVar) {\n    return null;\n  },\n\n  // called when a rule matches this item.\n  ruleMatched: function(aQuery, aRuleNode) { },\n\n  // the output for a result has been removed and the result is no longer being used by the builder\n  hasBeenRemoved: function() { }\n};\n\n\n// basic wrapper for nsISimpleEnumerator\nfunction TemplateResultSet(aArrayOfData) {\n  this._index = 0;\n  this._array = aArrayOfData;\n}\n\nTemplateResultSet.prototype = {\n  QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsISimpleEnumerator]),\n\n  hasMoreElements: function() {\n    return this._index &lt; this._array.length;\n  },\n\n  getNext: function() {\n    return new TemplateResult(this._array[this._index++]);\n  }\n};\n\n\n// The query processor class - implements nsIXULTemplateQueryProcessor\nfunction TemplateQueryProcessor() {\n  // our basic list of data\n  this._data = [\n                {name: \"mark\", age: 36, hair: \"brown\", eye: \"brown\"},\n                {name: \"bill\", age: 25, hair: \"red\", eye: \"black\"},\n                {name: \"joe\", age: 15, hair: \"blond\", eye: \"blue\"},\n                {name: \"jimmy\", age: 65, hair: \"gray\", eye: \"dull\"}\n               ];\n}\n\nTemplateQueryProcessor.prototype = {\n  QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsIXULTemplateQueryProcessor]),\n  classDescription: \"Sample XUL Template Query Processor\",\n  classID: Components.ID(\"{282cc4ea-a49c-44fc-81f4-1f03cbb7825f}\"),\n  contractID: \"@mozilla.org/xul/xul-query-processor;1?name=simpledata\",\n\n  getDatasource: function(aDataSources, aRootNode, aIsTrusted, aBuilder, aShouldDelayBuilding) {\n    // TODO: parse the aDataSources variable\n    // for now, ignore everything and let's just signal that we have data\n    return this._data;\n  },\n\n  initializeForBuilding: function(aDatasource, aBuilder, aRootNode) {\n    // perform any initialization that can be delayed until the content builder\n    // is ready for us to start\n  },\n\n  done: function() {\n    // called when the builder is destroyed to clean up state\n  },\n\n  compileQuery: function(aBuilder, aQuery, aRefVariable, aMemberVariable) {\n    // outputs a query object.\n    // eventually we should read the &lt;query&gt; to create filters\n    return this._data;\n  },\n\n  generateResults: function(aDatasource, aRef, aQuery) {\n    // preform any query and pass the data to the result set\n    return new TemplateResultSet(this._data);\n  },\n\n  addBinding: function(aRuleNode, aVar, aRef, aExpr) {\n    // add a variable binding for a particular rule, which we aren't using yet\n  },\n\n  translateRef: function(aDatasource, aRefstring) {\n    // if we return null, everything stops\n    return new TemplateResult(null);\n  },\n\n  compareResults: function(aLeft, aRight, aVar) {\n    // -1 less, 0 ==, +1 greater\n    var leftValue = aLeft.getBindingFor(aVar);\n    var rightValue = aRight.getBindingFor(aVar);\n    if (leftValue &lt; rightValue) {\n      return -1;\n    }\n    else if (leftValue &gt; rightValue) {\n      return  1;\n    }\n    else {\n      return 0;\n    }\n  }\n};\n\n\nvar components = [TemplateQueryProcessor];\n\nfunction NSGetModule(compMgr, fileSpec) {\n  return XPCOMUtils.generateModule(components);\n}\n</pre>\n\n<p>Our sample query processor is very simple. A few explanatory notes:</p>\n\n<ul>\n <li>We are using a the <code>getBindingFor</code> rather than <code>getBindingObjectFor</code> to simplify the code. The variable passed into <code>getBindingFor</code> still has the \"?\" prepended to it, so be sure to handle it appropriately.</li>\n <li>We are not handling any <code>datasources</code>, but instead hard code the datasource in the component. You could easily extend this sample to handle multiple datasources by checking the <code>datasources</code> value in <code>getDatasource</code> and <code>initializeForBuilding</code>.</li>\n <li>We do not make use of any <code>&lt;query/&gt;</code> or <code>&lt;rule/&gt;</code> elements in the XUL template block. These could be used to support filtering the datasource.</li>\n</ul>\n\n<div class=\"noinclude\"> </div>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>",
    "title": "How to implement a custom XUL query processor component"
}