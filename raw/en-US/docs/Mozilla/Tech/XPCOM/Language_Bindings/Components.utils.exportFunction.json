{
    "content": "<div> </div>\n\n<p class=\"summary\"><span class=\"seoSummary\">This function provides a safe way to expose a function from a privileged scope to a less-privileged scope.</span> In this way privileged code, such as an extension, can share code with less-privileged code like a normal web page script. A function exported from privileged to less-privileged code can be called from the less privileged code's context.</p>\n\n<p>The function has access to its surrounding closure just as if it were being called in the privileged context.<br>\n <br>\n The exported function does not have to be added to the less privileged code's global window object: it can be exported to any object in the target scope.</p>\n\n<p><code>exportFunction()</code> is made available as a global in sandboxes which have the <code>wantExportHelpers</code> option set in the <a href=\"https://developer.mozilla.org/en-US/docs/Components.utils.Sandbox\"><code>Sandbox()</code></a> constructor. This includes Add-on SDK <a href=\"/en-US/Add-ons/SDK/Guides/Content_Scripts\">content scripts</a>.</p>\n\n<p>To understand what happens if the functions you export accept arguments, see <a href=\"/en-US/docs/Components.utils.exportFunction#Exporting_functions_that_take_arguments\">Exporting functions that take arguments</a> below.</p>\n\n<h2 id=\"Syntax\">Syntax</h2>\n\n<pre class=\"brush: js\">Components.utils.exportFunction(func, targetScope[, options]);</pre>\n\n<h3 id=\"Parameters\">Parameters</h3>\n\n<dl>\n <dt><code>func : function</code></dt>\n <dd>The function to export.</dd>\n <dt><code>targetScope : object</code></dt>\n <dd>The object to attach the function to. This does not have to be the global window object: it could be any other object in the target window, or an object created by the caller.</dd>\n <dt><code>options : object</code></dt>\n <dd>Optional parameter that supplies additional options. The following options are currently defined:</dd>\n</dl>\n\n<ul>\n <li><code>defineAs</code>: determines the name of the function in <code>targetScope</code>. If this is omitted, you need to assign the return value of <code>exportFunction()</code> to an object in the target scope.</li>\n <li><code>allowCallbacks</code>: <strong>deprecated/redundant from Firefox 34</strong>. This option allows the exported function to accept callbacks as arguments. Boolean, defaulting to <code>false</code>. This option is new in Firefox 33. From Firefox 34 onwards this option has no effect: the exported function is always able to accept callbacks as arguments.</li>\n <li><code>allowCrossOriginArguments</code>: do not check that arguments to the exported function are <a href=\"/en-US/docs/Mozilla/Gecko/Script_security#Subsumes\">subsumed</a> by the caller: this allows the caller to pass objects with a different origin into the exported function, which can then use its privileged status to make cross-origin requests with them. Boolean, defaulting to <code>false</code>. This option is new in Firefox 34.</li>\n</ul>\n\n<h3 id=\"Returns\">Returns</h3>\n\n<p>The placeholder function which has been created in the target context.</p>\n\n<h2 id=\"Exporting_functions_that_take_arguments\">Exporting functions that take arguments</h2>\n\n<p>Until Firefox 34, any arguments that the function takes are <a href=\"/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm\">structured-cloned</a> across the security boundary unless they are native objects such as DOM nodes. Because structured cloning does not clone functions, this meant that the function may not return a function, and by default, may not take any functions as arguments. However, in Firefox 33, you could use the <code>allowCallbacks</code> option to enable the function to accept callbacks.</p>\n\n<p>From Firefox 34 onwards, any arguments passed into the function are not cloned. Instead, they are passed through to the privileged scope as <a href=\"/en-US/docs/Xray_vision\">Xrays</a>.</p>\n\n<h3 id=\"Modifying_the_argument\">Modifying the argument</h3>\n\n<p>While cloning creates a copy of an object, an Xray for an object refers to the original, so any changes to the argument that are made in the exported function will affect the original object that was passed in:</p>\n\n<pre class=\"brush: js\">// privileged scope: for example, a content script\n\nfunction changeMyName(user) {\n  user.name = \"Bill\";\n}\n\nexportFunction(changeMyName, contentWindow, {\n  defineAs: \"changeMyName\"\n});\n</pre>\n\n<pre class=\"brush: js\">// less-privileged scope: for example, a page script\n\nvar user = {name: \"Jim\"};\n\nvar test = document.getElementById(\"test\");\ntest.addEventListener(\"click\", function() {\n  console.log(user.name);            // \"Jim\"\n  window.changeMyName(user);\n  console.log(user.name);            // \"Bill\"\n}, false);</pre>\n\n<p>Note that this is subject to the normal rules of Xrays: for example, an expando property added to a DOM node will not be visible in the original object.</p>\n\n<h3 id=\"Xray_filtering_and_waiving\">Xray filtering and waiving</h3>\n\n<p>Xrays provide a filtered view of the original object. For the full details refer to the documentation for <a href=\"/en-US/docs/Xray_vision\">Xray vision</a>, but for example: functions are not visible in the Xrays of JavaScript <a href=\"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\" title=\"The Object constructor creates an object wrapper.\"><code>Object</code></a> types. If you need unfiltered access to the original, you can <a href=\"/en-US/docs/Xray_vision#Waiving_Xray_vision\">waive Xrays</a>:</p>\n\n<pre class=\"brush: js\">// privileged scope: for example, a content script\n\nfunction logUser(user) {\n // console.log(user.getUser());                 // error\n  console.log(user.wrappedJSObject.getUser());   // \"Bill\"\n}\n\nexportFunction(logUser, contentWindow, {\n  defineAs: \"logUser\"\n});</pre>\n\n<pre class=\"brush: js\">// less-privileged scope: for example, a page script\n\nvar user = {getUser: function() {return \"Bill\";}}\n\nvar test = document.getElementById(\"test\");\ntest.addEventListener(\"click\", function() {\n  window.logUser(user);\n}, false);</pre>\n\n<h3 id=\"Passing_functions_as_arguments\">Passing functions as arguments</h3>\n\n<p>If functions are given as arguments, these are also passed as Xrays. Because you can call <code>Function</code> Xrays just like normal functions, this means that passing callbacks into the exported function just works, making the <code>allowCallbacks</code> option redundant:</p>\n\n<pre class=\"brush: js\">// privileged scope: for example, a content script\n\nfunction logUser(getUser) {\n  console.log(getUser());   // \"Bill\"\n}\n\nexportFunction(logUser, unsafeWindow, {\n  defineAs: \"logUser\"\n});</pre>\n\n<pre class=\"brush: js\">// less-privileged scope: for example, a page script\n\nfunction getUser() {\n  return \"Bill\";\n}\n\nvar test = document.getElementById(\"test\");\ntest.addEventListener(\"click\", function() {\n  window.logUser(getUser);\n}, false);</pre>\n\n<h3 id=\"Cross-origin_checking\">Cross-origin checking</h3>\n\n<p>When the exported function is called each argument, including <code>this</code>, is checked to make sure that the caller <a href=\"/en-US/docs/Mozilla/Gecko/Script_security#Subsumes\">subsumes</a> that argument. This prevents passing cross-origin objects (like <code>Window</code> or <code>Location</code>) to privileged functions, since the privileged code will have full access to those objects and might unintentionally do something dangerous. This provision can be overridden by passing <code>{ allowCrossOriginArguments: true }</code> to <code>exportFunction</code>.</p>\n\n<h2 id=\"Example\">Example</h2>\n\n<h3 id=\"Export_to_global_scope\">Export to global scope</h3>\n\n<p>This add-on script defines a function, then exports it to a content window:</p>\n\n<pre class=\"brush: js\">// addon-script.js\n\nvar salutation = \"hello \";\n\nfunction greetme(user) {\n  return salutation + user;\n}\n\nComponents.utils.exportFunction(greetme, contentWindow, {defineAs: \"foo\"});\n</pre>\n\n<p>Instead of using <code>defineAs</code>, the script can assign the result of <code>exportFunction</code> to an object in the target scope:</p>\n\n<pre class=\"brush: js\">// addon-script.js\n\nvar salutation = \"hello \";\n\nfunction greetme(user) {\n  return salutation + user;\n}\n\ncontentWindow.foo = Components.utils.exportFunction(greetme, contentWindow);</pre>\n\n<p>Either way, code running in the content window's scope can now call the function:</p>\n\n<pre class=\"brush: js\">// page-script.js\n\nvar greeting = foo(\"alice\");\nconsole.log(greeting);\n// \"hello alice\"</pre>\n\n<h3 id=\"Export_to_an_existing_local_object\">Export to an existing local object</h3>\n\n<p>Instead of attaching the function to the target's global <code>window</code> object, the caller can attach it to any other object in the target context. Suppose the content window defines a local variable <code>bar</code>:</p>\n\n<pre class=\"brush: js\">// page-script.js\n\nvar bar = {};</pre>\n\n<p>Now the add-on script can attach the function to <code>bar</code>:</p>\n\n<pre class=\"brush: js\">// addon-script.js\n\nComponents.utils.exportFunction(greetme, contentWindow.bar, {defineAs: \"greetme\"});</pre>\n\n<pre class=\"brush: js\">// page-script.js\n\nvar value = bar.greetme(\"bob\");\nconsole.log(value);\n// \"hello bob\"</pre>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/mdnwebdocs-bot\">mdnwebdocs-bot</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/ExE-Boss\">ExE-Boss</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/Sheppy\">Sheppy</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/teoli\">teoli</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/BlindWanderer\">BlindWanderer</a>",
    "title": "Components.utils.exportFunction"
}