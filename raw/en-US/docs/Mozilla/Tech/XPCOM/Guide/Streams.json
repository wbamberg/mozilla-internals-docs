{
    "content": "<h2 id=\"What_are_streams\">What are streams?</h2>\n\n<p>In Mozilla code, a stream is an object which represents access to a sequence of characters.  It is not that sequence of characters, though: the characters may not all be available when you read from the stream. </p>\n\n<p>Think of a water tank with a spout:  the tank may be full, or it may be half-full, or it may be empty. The spout controls how much water you can get out of the tank at a time. The spout is a source of water. If we think of the water as data, then the spout represents an <em>input stream</em>: a controller for data coming out of something. At the same time, there may be some way to put water into the tank - say, a main water line. That water line represents an <em>output stream</em>: a controller for data going into something.</p>\n\n<p>The actual data going in to and coming out of an object isn't usually important to a stream. Streams simply provide a way to read or write data to some object.</p>\n\n<p>In basic C++ programming for a console application, we usually talk about streams to access files, or to interact with the user. Mozilla's use of streams is more complex. On the one hand, we don't interact with the user through streams. On the other hand, we use streams to access files within a ZIP archive, to store and provide data coming from websites, even to talk to other programs on the same computer through \"pipes\" (more on that later). We even have streams that take input from other streams and transform the data within them to something more useful.</p>\n\n<h2 id=\"Primitive_streams\">Primitive streams</h2>\n\n<p>There are streams for several different types of data storage.  Each of these implements nsIInputStream.</p>\n\n<table>\n <caption>Primitive Input Streams</caption>\n <thead>\n  <tr>\n   <th scope=\"row\">Type</th>\n   <th scope=\"col\">Native Class</th>\n   <th scope=\"col\">Contract ID</th>\n   <th scope=\"col\">Interface</th>\n   <th scope=\"col\">How to bind to a data source</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th scope=\"row\">Generic</th>\n   <td>nsStorageInputStream</td>\n   <td>N/A</td>\n   <td>nsIInputStream, nsISeekableStream</td>\n   <td>\n    <p>storageStream.newInputStream();</p>\n   </td>\n  </tr>\n  <tr>\n   <th scope=\"row\">String (8-bit characters)</th>\n   <td>nsStringStream</td>\n   <td>@mozilla.org/io/string-input-stream;1</td>\n   <td>nsIStringInputStream</td>\n   <td>stream.setData(<em>data, length</em>);</td>\n  </tr>\n  <tr>\n   <th scope=\"row\">File</th>\n   <td>nsFileInputStream</td>\n   <td>@mozilla.org/network/file-input-stream;1</td>\n   <td>nsIFileInputStream</td>\n   <td>stream.init(<em>file, ioFlags, perm, behaviorFlags)</em>;</td>\n  </tr>\n  <tr>\n   <th scope=\"row\">ZIP</th>\n   <td>nsJARInputStream</td>\n   <td>N/A</td>\n   <td>nsIInputStream</td>\n   <td>\n    <p>zipReader.getInputStream(<em>zipEntry</em>);</p>\n   </td>\n  </tr>\n </tbody>\n</table>\n\n<p>Similarly, each of these implements nsIOutputStream.</p>\n\n<table>\n <caption>Primitive Output Streams</caption>\n <thead>\n  <tr>\n   <th scope=\"row\">Type</th>\n   <th scope=\"col\">Native Class</th>\n   <th scope=\"col\">Contract ID</th>\n   <th scope=\"col\">Interface</th>\n   <th scope=\"col\">How to bind to a data target</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th scope=\"row\">Generic</th>\n   <td>nsStorageStream</td>\n   <td>@mozilla.org/storagestream;1</td>\n   <td>nsIStorageStream</td>\n   <td>stream.getOutputStream(); // returns nsIOutputStream</td>\n  </tr>\n  <tr>\n   <th scope=\"row\">File</th>\n   <td>nsFileOutputStream</td>\n   <td>@mozilla.org/network/file-output-stream;1</td>\n   <td>nsIFileOutputStream</td>\n   <td>stream.init(<em>file, ioFlags, perm, behaviorFlags)</em>;</td>\n  </tr>\n  <tr>\n   <th scope=\"row\">File</th>\n   <td>nsSafeFileOutputStream</td>\n   <td>@mozilla.org/network/safe-file-output-stream;1</td>\n   <td>\n    <p>nsISafeFileOutputStream,</p>\n\n    <p>nsIFileOutputStream</p>\n   </td>\n   <td>stream.init(<em>file, ioFlags, perm, behaviorFlags)</em>;</td>\n  </tr>\n </tbody>\n</table>\n\n<h3 id=\"Channels_have_streams_too\">Channels have streams too</h3>\n\n<p>Any implementation of <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIChannel\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIChannel\">nsIChannel</a> will have an input stream as well, but unless you own the channel, you shouldn't try to read from the input stream. There are two ways of getting the input stream: by calling<em> </em>the channel's .open() method for a synchronous read, or by calling the channel's .asyncOpen() method with an <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIStreamListener\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIStreamListener\">nsIStreamListener</a> object.</p>\n\n<p>You can get an nsIChannel object from the <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIIOService\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIIOService\">IO Service</a>'s <em>newChannel(spec, charset, baseURI)</em> method or its <em>.newChannelFromURI(uri)</em> method.</p>\n\n<h3 id=\"The_safe_file_output_stream\">The \"safe file output stream\"</h3>\n\n<p>Mozilla provides a \"safe file output stream\" implementation. This implementation actually writes the contents of the file you're trying to create to a temporary file. If everything goes well, calling the stream's <em>.finish()</em> method overwrites the original file with the new file.</p>\n\n<h2 id=\"Using_Streams_in_C\">Using Streams in C++</h2>\n\n<h2 id=\"Using_Streams_in_JavaScript\">Using Streams in JavaScript</h2>\n\n<h3 id=\"Input_Streams\">Input Streams</h3>\n\n<p>Input streams are not scriptable - you cannot directly call .read() on them, for example. To solve this, there is a special <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIScriptableInputStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIScriptableInputStream\">nsIScriptableInputStream</a> interface and \"scriptable stream\" wrapper. If you have an input stream called nativeStream, you can use code like this:</p>\n\n<pre class=\"brush: js\">var stream = Components.classes[\"@mozilla.org/scriptableinputstream;1\"]\n                       .createInstance(Components.interfaces.nsIScriptableInputStream);\nstream.init(nativeStream);</pre>\n\n<p>The stream provides .read(<em>count</em>), .available(), and .close() methods.</p>\n\n<h3 id=\"Output_Streams\">Output Streams</h3>\n\n<p>Output streams are usually scriptable:  you can call .write(chars, chars.length) as you wish. However, it is usually better to create an input stream that you then feed to the output stream:</p>\n\n<pre>var outStream = Components.classes[\"@mozilla.org/storagestream;1\"]\n                          .createInstance(Components.interfaces.nsIStorageStream)\n                          .getOutputStream();\nvar inStream = Components.classes[\"@mozilla.org/io/string-input-stream;1\"]\n                         .createInstance(Components.interfaces.nsIStringInputStream);\nvar data = \"Hello World\";\ninStream.setData(data, data.length);\nwhile (inStream.available()) {\n    outStream.writeFrom(inStream, inStream.available());\n}\n</pre>\n\n<p>Note this is an inefficient example:  the only important part is how to feed the output stream.  This is also a synchronous (blocking) operation, so if you're in JavaScript, consider using NetUtil.jsm as described below.</p>\n\n<h3 id=\"A_note_about_Unicode_strings_versus_nsIInputStream\">A note about Unicode strings versus nsIInputStream</h3>\n\n<p>nsIInputStream and nsIOutputStream work with <em>8-bit</em> characters.  However, JavaScript strings contain <em>16-bit</em> characters.  This can mean if you have characters beyond ASCII code 255, you risk losing data using nsStringStream, for example.</p>\n\n<p>To get an input stream for JavaScript strings safely, try this.</p>\n\n<pre>var converter = Components.classes[\"@mozilla.org/intl/scriptableunicodeconverter\"]\n                          .createInstance(Components.interfaces.nsIScriptableUnicodeConverter);\nconverter.charset = \"UTF-8\";\nvar stream = converter.convertToInputStream(string);</pre>\n\n<h3 id=\"JavaScript_modules_are_your_friends\">JavaScript modules are your friends</h3>\n\n<p>There are several useful <a href=\"/en-US/docs/Mozilla/JavaScript_code_modules\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules\">JavaScript modules</a> at your disposal. For streams, the most obvious are <a href=\"/en-US/docs/Mozilla/JavaScript_code_modules/NetUtil.jsm\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules/NetUtil.jsm\">NetUtil.jsm</a> and <a href=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm\">FileUtils.jsm</a>.  NetUtil.jsm provides APIs for copying an input stream to an output stream (the <em>asyncCopy()</em> method), getting an input stream from another source (the <em>asyncFetch()</em> method), and reading an input stream into a string (the <em>readInputStreamToString()</em> method).  FileUtils.jsm provides APIs for getting output streams for files, with the <a href=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm#openFileOutputStream()\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm#openFileOutputStream()\"><em>.openFileOutputStream(file, modeFlags)</em></a> and <a href=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm#openSafeFileOutputStream()\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm#openSafeFileOutputStream()\"><em>.openSafeFileOutputStream(file, modeFlags) </em></a>methods, and for closing those output streams with the <em><a href=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm#closeSafeFileOutputStream()\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules/FileUtils.jsm#closeSafeFileOutputStream()\">.closeSafeFileOutputStream(inputStream)</a></em> method.</p>\n\n<p>As we mentioned earlier, you can use the IO service to get any channel, and from there an input stream. The IO service is available through the <a href=\"/en-US/docs/Mozilla/JavaScript_code_modules/Services.jsm\" title=\"/en-US/docs/Mozilla/JavaScript_code_modules/Services.jsm\">Services.jsm</a> module as the <em>.io</em> property.</p>\n\n<h2 id=\"Stream_Listeners\">Stream Listeners</h2>\n\n<p>A stream listener is an object you build to let you know when there is data in a stream ready for you to consume. Most streams are asynchronous: they make no assumptions that all the data a resource provides is available immediately. (This is particularly true of streams that reach out over a network connection, like HTTP and FTP channels.)</p>\n\n<p>Stream listeners implement three methods. From the <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIStreamListener\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIStreamListener\">nsIStreamListener</a> interface, the <em>.onDataAvailable(request, context, inputStream, offset, count)</em> method gives you the input stream and the number of bytes available. The stream listener must read exactly <em>count</em> bytes before exiting. From the <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIRequestObserver\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIRequestObserver\">nsIRequestObserver</a> interface, the <em>.onStartRequest(request, context)</em> method tells you when the request begins, while the <em>.onStopRequest(request, context)</em> method tells you when the request ends. A request will have one <em>.onStartRequest(request, context)</em> call, followed by at least one <em>.onDataAvailable(...)</em> call, followed by one <em>.onStopRequest(request, context)</em> call.</p>\n\n<p>The context argument will be something passed from whoever invokes the request to the <em>.onStartRequest()</em>, <em>.onDataAvailable()</em>, and <em>.onStopRequest()</em> methods of the listener.</p>\n\n<p>As for passing in the stream listener and starting the request: that will vary depending on the use case.</p>\n\n<h2 id=\"Seekable_Streams\">Seekable Streams</h2>\n\n<p>Some streams are \"seekable\": they let you specify where in the stream you are reading from (instead of requiring it be from the beginning). They can also report their current position in the file. Seekable streams implement the <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsISeekableStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsISeekableStream\">nsISeekableStream</a> interface.</p>\n\n<p>The following stream types are known to implement nsISeekableStream:</p>\n\n<ul>\n <li>nsStorageInputStream</li>\n <li>nsStringInputStream</li>\n <li>nsMultiplexInputStream</li>\n <li>nsPipeInputStream</li>\n <li>nsFileInputStream</li>\n <li>nsBufferedInputStream</li>\n <li>nsFileOutputStream</li>\n <li>nsBufferedOutputStream</li>\n</ul>\n\n<h2 id=\"Complex_stream_types\">Complex stream types</h2>\n\n<p>Several stream types leverage primitive stream types to do specialized work. These work by taking the input from another stream, and providing a stream interface to access that underlying stream's data.</p>\n\n<table>\n <caption>Complex Input Stream Types</caption>\n <thead>\n  <tr>\n   <th scope=\"row\">Type</th>\n   <th scope=\"col\">Purpose</th>\n   <th scope=\"col\">Native Class</th>\n   <th scope=\"col\">Contract ID</th>\n   <th scope=\"col\">Interface</th>\n   <th scope=\"col\">How to bind to a primitive input stream</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th scope=\"row\">Multiplex</th>\n   <td>Concatenate multiple input streams into one.</td>\n   <td>nsMultiplexInputStream</td>\n   <td>@mozilla.org/io/multiplex-input-stream;1</td>\n   <td>nsIMultiplexInputStream</td>\n   <td>\n    <p><em>.appendStream(stream)</em></p>\n\n    <p><em>.insertStream(stream, index)</em></p>\n   </td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Buffered</th>\n   <td>Read ahead in the underlying stream into a buffer, so that calls to the underlying stream are minimized.</td>\n   <td>nsBufferedInputStream</td>\n   <td>@mozilla.org/network/buffered-input-stream;1</td>\n   <td>nsIBufferedInputStream</td>\n   <td><em>.init(stream, bufferSize)</em></td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Binary</th>\n   <td>Read binary data from the underlying stream, in \"big-endian\" order.</td>\n   <td>nsBinaryInputStream</td>\n   <td>@mozilla.org/binaryinputstream;1</td>\n   <td><a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIBinaryInputStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIBinaryInputStream\">nsIBinaryInputStream</a></td>\n   <td><em>.setInputStream(stream)</em></td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Object</th>\n   <td>Read a nsISupports object from the underlying stream.</td>\n   <td>nsBinaryInputStream</td>\n   <td>@mozilla.org/binaryinputstream;1</td>\n   <td>nsIObjectInputStream</td>\n   <td>(inherits from nsIBinaryInputStream)</td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Converter</th>\n   <td>Convert Unicode characters from an underlying stream.</td>\n   <td>nsConverterInputStream</td>\n   <td>@mozilla.org/intl/converter-input-stream;1</td>\n   <td><a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIConverterInputStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIConverterInputStream\">nsIConverterInputStream</a></td>\n   <td><em>.init(stream, charset, bufferSize, replaceChar)</em></td>\n  </tr>\n  <tr>\n   <th scope=\"row\">MIME</th>\n   <td>Separate headers from data.</td>\n   <td>nsMIMEInputStream</td>\n   <td>@mozilla.org/network/mime-input-stream;1</td>\n   <td><a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIMIMEInputStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIMIMEInputStream\">nsIMIMEInputStream</a></td>\n   <td><em>.setData(stream)</em></td>\n  </tr>\n </tbody>\n</table>\n\n<p>Similarly, there are complex output streams which build from primitive output streams:</p>\n\n<table>\n <caption>Complex Output Stream Types</caption>\n <thead>\n  <tr>\n   <th scope=\"row\">Type</th>\n   <th scope=\"col\">Purpose</th>\n   <th scope=\"col\">Native Class</th>\n   <th scope=\"col\">Contract ID</th>\n   <th scope=\"col\">Interface</th>\n   <th scope=\"col\">How to bind to a primitive output stream</th>\n  </tr>\n </thead>\n <tbody>\n  <tr>\n   <th scope=\"row\">Buffered</th>\n   <td>Store data in a buffer until the buffer is full or the stream closes.  Then, write that data to the underlying stream.</td>\n   <td>nsBufferedOutputStream</td>\n   <td>@mozilla.org/network/buffered-output-stream;1</td>\n   <td>nsIBufferedOutputStream</td>\n   <td><em>.init(stream, bufferSize)</em></td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Binary</th>\n   <td>Write binary data to the underlying stream, in \"big-endian\" order.</td>\n   <td>nsBinaryOutputStream</td>\n   <td>@mozilla.org/binaryoutputstream;1</td>\n   <td><a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIBinaryOutputStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIBinaryOutputStream\">nsIBinaryOutputStream</a></td>\n   <td><em>.setOutputStream(stream)</em></td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Object</th>\n   <td>Write an nsISupports object to the underlying stream.</td>\n   <td>nsBinaryOutputStream</td>\n   <td>@mozilla.org/binaryoutputstream;1</td>\n   <td>nsIObjectOutputStream</td>\n   <td>(inherits from nsIBinaryOutputStream)</td>\n  </tr>\n  <tr>\n   <th scope=\"row\">Converter</th>\n   <td>Write to an underlying stream with automatic conversion of Unicode characters.</td>\n   <td>nsConverterOutputStream</td>\n   <td>@mozilla.org/intl/converter-output-stream;1</td>\n   <td><a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIConverterOutputStream\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIConverterOutputStream\">nsIConverterOutputStream</a></td>\n   <td><em>.init(stream, charset, bufferSize, replaceChar)</em></td>\n  </tr>\n </tbody>\n</table>\n\n<h2 id=\"Additional_Stream_Interfaces\">Additional Stream Interfaces</h2>\n\n<ul>\n <li>The nsILineInputStream interface supports a <em>.readLine()</em> method for reading a single line from an input stream. The nsFileInputStream and nsPartialFileInputStream classes implement this interface.</li>\n <li>(XXX nsIUnicharInputStream interface)</li>\n <li>(XXX nsIUnicharLineInputStream interface)</li>\n <li>(XXX nsISearchableInputStream interface)</li>\n</ul>\n\n<h2 id=\"Stream_Converters\">Stream Converters</h2>\n\n<p>(TBD: @mozilla.org/streamConverters;1)</p>\n\n<h2 id=\"Forcing_an_input_stream_to_be_read\">Forcing an input stream to be read</h2>\n\n<p>Suppose you already have an input stream, and something to read from that input stream...but the reader doesn't do anything with the stream. Suppose that reader also implements nsIStreamListener. Mozilla provides an \"input stream pump\" component to feed data from the stream into the reader.</p>\n\n<p>There are two parts: initializing the pump, and telling it to asynchronously read data into the stream listener:</p>\n\n<pre class=\"brush: js\">var pump = Components.classes[\"@mozilla.org/network/input-stream-pump;1\"]\n                     .createInstance(Components.interfaces.nsIInputStreamPump);\npump.init(stream, -1, -1, 0, 0, true);\n\npump.asyncRead(listener, context);\n</pre>\n\n<p> </p>\n\n<h3 id=\"nsIPipe\">nsIPipe</h3>\n\n<h2 id=\"Code_Examples\">Code Examples</h2>\n\n<h3 id=\"File_input_and_output\">File input and output</h3>\n\n<p>For file input, see <a href=\"/en-US/docs/Code_snippets/File_I_O#Reading_from_a_file\" title=\"/en-US/docs/Code_snippets/File_I_O#Reading_from_a_file\">Code Snippets: Reading from a file</a>.  For file output, see <a href=\"/en-US/docs/Code_snippets/File_I_O#Writing_to_a_file\" title=\"/en-US/docs/Code_snippets/File_I_O#Writing_to_a_file\">Code Snippets: Writing to a file</a>.</p>\n\n<h3 id=\"ZIP_input_and_output\">ZIP input and output</h3>\n\n<p>For getting an input stream from a ZIP archive, see the <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIZipReader\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIZipReader\">nsIZipReader</a> interface:</p>\n\n<pre class=\"brush: js\">// file is an nsIFile object mapping to a ZIP archive\nvar zipReader = Components.classes[\"@mozilla.org/libjar/zip-reader;1\"]\n                          .createInstance(Components.interfaces.nsIZipReader);\nzipReader.open(file);\nvar stream = zipReader.getInputStream(\"/path/to/zipped/file\");\n\n// process the stream\n\n// when we don't need the zipReader anymore\nzipReader.close();\n</pre>\n\n<p>For writing from an input stream to a ZIP archive, see the <a href=\"/en-US/docs/XPCOM_Interface_Reference/nsIZipWriter\" title=\"/en-US/docs/XPCOM_Interface_Reference/nsIZipWriter\">nsIZipWriter</a> interface:</p>\n\n<pre class=\"brush: js\">// file is an nsIFile object mapping to a ZIP archive\nvar zipWriter = Components.classes[\"@mozilla.org/zipwriter;1\"]\n                          .createInstance(Components.interfaces.nsIZipWriter);\n\nzipWriter.open(file, ioFlags);\n\n// stream is the output stream\nzipWriter.addEntryStream(\"/path/to/zipped/file\", modTime, compression, stream, queueForLater);\n\n// if queued for later operations, and all operations are queued\nzipWriter.processQueue();\n\n// when we don't need the zipWriter anymore\nzipWriter.close();\n</pre>\n\n<p> </p>\n\n<h3 id=\"Concatenating_input_streams\">Concatenating input streams</h3>\n\n<pre class=\"brush: js\">var StringStream = Components.Constructor(\"@mozilla.org/io/string-input-stream;1\",\n                                          \"nsIStringInputStream\",\n                                          \"setData\");\n\nfunction buildStream(data) {\n  return new StringStream(data, data.length);\n}\n\nfunction run_test() {\n  var str1 = buildStream(\"We \");\n  var str2 = buildStream(\"will \");\n  var str3 = buildStream(\"rock \");\n  var str4 = buildStream(\"you!\");\n\n  var check = \"We will rock you!\";\n\n  var multi = Components.classes[\"@mozilla.org/io/multiplex-input-stream;1\"]\n                        .createInstance(Components.interfaces.nsIMultiplexInputStream);\n  multi.appendStream(str1);\n  multi.appendStream(str2);\n  multi.appendStream(str3);\n  multi.appendStream(str4);\n\n  var inStream = Components.classes[\"@mozilla.org/scriptableinputstream;1\"]\n                           .createInstance(Components.interfaces.nsIScriptableInputStream);\n  inStream.init(multi);\n  var data = inStream.read(inStream.available());\n\n  // check == data;\n}\n</pre>\n\n<h3 id=\"Creating_copies_of_an_input_stream\">Creating copies of an input stream</h3>\n\n<pre class=\"brush: js\">var StringStream = Components.Constructor(\"@mozilla.org/io/string-input-stream;1\",\n                                          \"nsIStringInputStream\",\n                                          \"setData\");\n\nvar InputStream = Components.Constructor(\"@mozilla.org/scriptableinputstream;1\",\n                                         \"nsIScriptableInputStream\",\n                                         \"init\");\n\nfunction buildStream(data) {\n  return new StringStream(data, data.length);\n}\n\nComponents.utils.import(\"resource://gre/modules/NetUtil.jsm\");\n\nfunction run_test() {\n  var check = \"We will rock you!\";\n \n  var baseInputStream = buildStream(check);\n \n  var store = Components.classes[\"@mozilla.org/storagestream;1\"]\n                        .createInstance(Components.interfaces.nsIStorageStream);\n  /* In practice, your storage streams shouldn't be this small.  The first argument,\n   * which represents capacity per segment, is far too small for practical use.\n   */\n  store.init(64, 64, null); \n\n  var out = store.getOutputStream(0);\n\n  NetUtil.asyncCopy(baseInputStream, out, function(status) {\n    if (status != Components.results.NS_OK)\n      return;\n    /* Due to a crash, we can't create input streams until the storage output stream\n     * has some data in it.\n     *\n     * Also, baseInputStream has been completely consumed at this point, so we\n     * shouldn't read from it anymore. (However, because baseInputStream is an\n     * nsStringInputStream, it is also a seekable stream...so we could go to\n     * the beginning if we wanted to.)\n     */\n    var str1 = store.newInputStream(0);\n    var d1 = new InputStream(str1);\n    // d1 has a complete copy of baseInputStream's original contents.\n\n    var d2 = new InputStream(store.newInputStream(0));\n    // d2 has a complete copy of baseInputStream's original contents.\n  });\n}</pre>\n\n<h3 id=\"Parsing_a_DOM_document_from_an_input_stream\">Parsing a DOM document from an input stream</h3>\n\n<p> </p>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/mdnwebdocs-bot\">mdnwebdocs-bot</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/WeirdAl\">WeirdAl</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/Standard8\">Standard8</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/Sheppy\">Sheppy</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/kscarfone\">kscarfone</a>",
    "title": "XPCOM Stream Guide"
}