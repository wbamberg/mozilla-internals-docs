{
    "content": "<p><span class=\"seoSummary\">In the Mozilla platform, most activities such as layout, <a href=\"/en/DOM\" title=\"DOM\">DOM</a> operations, content <a href=\"/en/JavaScript\" title=\"JavaScript\">JavaScript</a>, and chrome JavaScript run on the main thread. However, it may be useful for C++ code in the Mozilla platform to run tasks on another thread.</span> Typically, thread activities are triggered and managed using an <a href=\"/en/XPCOM\" title=\"XPCOM\">XPCOM</a> event-passing framework that uses the <code><a href=\"/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIRunnable\" title=\"\">nsIRunnable</a></code> interface. Each runnable represents a task which can then be dispatched to another thread for execution.</p>\n<div class=\"note\">\n <strong>Note:</strong> JavaScript code cannot use the techniques described in this article. Chrome JavaScript should instead use <a href=\"/en/DOM/ChromeWorker\" title=\"en/DOM/ChromeWorker\">workers</a>.</div>\n<p>In general, threading and message passing should be asynchronous. For example, let's say we have a function, <code>CalculatePi(int digits)</code>, which will calculate Ï€ to an arbitrary number of digits:</p>\n<pre class=\"brush:c++;\">void CalculatePi(int digits, nsCString&amp; result); // This is synchronous\n</pre>\n<p>This can take a while, so we don't want to run this on the main thread. Instead, we want to run it on a new thread and be notified when the result is available. So we declare an asynchronous version of the same function:</p>\n<pre class=\"brush:c++;\">typedef void (*PiCallback)(const nsCString&amp; result); // Callback function\nvoid CalculatePiAsynchronously(int digits, PiCallback callback);\n</pre>\n<h3 id=\"Creating_a_runnable\">Creating a runnable</h3>\n<p><code>nsRunnable</code> is a helper class: it already implements threadsafe refcounting, so all you need to do is override the <code>Run()</code> function. In our example, we actually need two runnables: one dispatched to the worker thread, and one to hand us back the result.</p>\n<pre class=\"brush:c++;\">#include \"nsThreadUtils.h\"\n\nclass PiResultTask : public nsRunnable\n{\npublic:\n  PiResultTask(PiCallback callback, const nsACString&amp; result)\n    : mCallback(callback)\n    , mResult(result)\n    , mWorkerThread(do_GetCurrentThread())\n  {\n    MOZ_ASSERT(!NS_IsMainThread()); // This should be running on the worker thread\n  }\n\n  NS_IMETHOD Run() {\n    MOZ_ASSERT(NS_IsMainThread()); // This method is supposed to run on the main thread!\n    mCallback(mResult);\n    \n    // If we don't destroy the thread when we're done with it, it will hang around forever... bad!\n    // But thread-&gt;Shutdown must be called from the main thread, not from the thread itself.\n    mWorkerThread-&gt;Shutdown();\n  }\n\nprivate:\n  PiCallback mCallback;\n  nsCString mResult;\n  nsCOMPtr&lt;nsIThread&gt; mWorkerThread;\n};\n\nclass PiCalculateTask : public nsRunnable\n{\npublic:\n  PiCalculateTask(PiCallback callback, int digits)\n    : mCallback(callback)\n    , mDigits(digits)\n  { }\n\n  NS_IMETHOD Run() {\n    nsCString result;\n    CalculatePi(mDigits, result);\n    nsCOMPtr&lt;nsIRunnable&gt; resultrunnable = new PiResultTask(mCallback, result);\n    NS_DispatchToMainThread(resultrunnable);\n  }\n\nprivate:\n  PiCallback mCallback;\n  int mDigits;\n};\n</pre>\n<h3 id=\"Putting_it_all_together\">Putting it all together</h3>\n<p>To start a new thread, create it using the <a href=\"/en/The_Thread_Manager\" title=\"The Thread Manager\">Thread Manager</a>:</p>\n<pre class=\"brush:c++;\"><code>#include \"nsXPCOMCIDInternal.h\"\n\n</code>void CalculatePiAsynchronously(int digits, PiCallback callback)\n{\n  // To create a new thread, get the thread manager\n<code>  nsCOMPtr&lt;nsIThreadManager&gt;</code> tm = do_GetService(NS_THREADMANAGER_CONTRACTID);\n  nsCOMPtr&lt;nsIThread&gt; mythread;\n  nsresult rv = tm-&gt;NewThread(0, 0, getter_AddRefs(mythread));\n  if (NS_FAILED(rv)) {\n    // In case of failure, call back immediately with an empty string which indicates failure\n    callback(EmptyCString());\n    return;\n  }\n  \n  nsCOMPtr&lt;nsIRunnable&gt; r = new PiCalculateTask(callback, digits);\n  \n  mythread-&gt;Dispatch(r, nsIEventTarget::DISPATCH_NORMAL);\n  // The result callback will shut down the worker thread, we can let it go here...\n}\n</pre>\n<h3 id=\"See_also\">See also</h3>\n<ul>\n <li><a href=\"/en/DOM/ChromeWorker\" title=\"ChromeWorker\">ChromeWorker</a></li>\n <li><a href=\"/en/JavaScript_code_modules/Using_workers_in_JavaScript_code_modules\" title=\"Using workers in JavaScript code modules\">Using workers in JavaScript code modules</a></li>\n <li><a href=\"/en/The_Thread_Manager\" title=\"The Thread Manager\">The Thread Manager</a></li>\n</ul>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/mdnwebdocs-bot\">mdnwebdocs-bot</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/Sheppy\">Sheppy</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/Dexterp37\">Dexterp37</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/fscholz\">fscholz</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/kscarfone\">kscarfone</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/bsmedberg\">bsmedberg</a>",
    "title": "Making cross-thread calls using runnables"
}