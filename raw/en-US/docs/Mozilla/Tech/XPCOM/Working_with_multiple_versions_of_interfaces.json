{
    "content": "<h2 id=\"The_Problem\"> The Problem </h2>\n<p>In this short note we illustrate how one can update an XPCOM module in\norder for it to work in both Firefox 2 and Firefox 3, even if the interfaces have\nchanged in the interim. </p><p>In the extension that prompted this note, I needed to obtain the <code>HWND</code> of the document (yes its on Windows) in order to identify\neach particular extension instance. To do this I used the accessibility framework:\n</p>\n<pre>HWND getHwnd(nsIDOMNode *node){\n  HWND self = NULL;\n  nsresult rv;\n  nsCOMPtr&lt;nsIAccessibleRetrieval&gt; refp; \n  refp = do_CreateInstance( \"@mozilla.org/accessibleRetrieval;1\", &amp;rv);\n  if (NS_FAILED(rv)){ return self; } //line 6.\n  nsCOMPtr&lt;nsIAccessible&gt; accnode;\n  rv = refp-&gt;GetAccessibleFor(node, getter_AddRefs(accnode));\n  if(NS_FAILED(rv)){ return self; }\n  void *wh = NULL;\n  nsCOMPtr&lt;nsIAccessibleDocument&gt; accdocnode;\n  accdocnode = do_QueryInterface(accnode, &amp;rv);\n  if(NS_FAILED(rv)){ return self; }\n  rv = accdocnode-&gt;GetWindowHandle(&amp;wh);\n  if(NS_SUCCEEDED(rv)){ self = static_cast&lt;HWND&gt;(wh); }\n  return self;\n}\n</pre>\n<p>This approach worked, as is, for versions as early as Firefox 1.5.\nThe problem arises when one tries to run an extension built with the latest\nSDK in an older version of Firefox, say Firefox 2. What happens is that the call to <code>do_CreateInstance</code> fails with <code>nsresult NS_ERROR_NO_INTERFACE</code>.\nThis is because the call to </p>\n<pre>do_CreateInstance(aCID, aOuter, error);\n</pre>\n<p>will eventually evolve into a request for an object supporting the interface\nwith IID <code>NS_GET_IID(nsIAccessibleRetrieval)</code>. Unfortunately we compiled\nthis in the latest SDK, and so this magic number happens to be:\n</p>\n<pre>\"244e4c67-a1d3-44f2-9cab-cdaa31b68046\"\n</pre>\n<p>whereas, inside Firefox 2, the IID it happens to know about is:\n</p>\n<pre>\"663ca4a8-d219-4000-925d-d8f66406b626\".\n</pre>\n<p><br>\nand this explains our <code>NS_ERROR_NO_INTERFACE</code>. </p><p>Fortunately there is a plan of action that we can follow to rectify\nthis. We build construct our XPCOM component so that first tries to\nget the interface by it's new IID, then if that fails, attempts plan B.\nPlan B is simply trying to get the interface by it's older IID. </p><p>For expository purposes we will do this in two stages; buoyed by the\nfact that it is the actual route we took.\n</p>\n<h2 id=\"The_Optimist's_Solution\"> The Optimist's Solution </h2>\n<p>The first thing we do is replace line 6 above by our plan B:\n</p>\n<pre>  if (NS_FAILED(rv)){ return getHwndB(node); } //new line 6.\n</pre>\n<p>and then implement plan B. We first dredge out the old interface identifiers\nfrom our yea olde Firefox 1.5 SDK:\n</p>\n<pre>static const nsIID IAR_IID_OLD =\n  { 0x663ca4a8, 0xd219, 0x4000, { 0x92, 0x5d, 0xd8, 0xf6, 0x64, 0x06, 0xb6, 0x26 }};\n\nstatic const nsIID IAD_IID_OLD = \n  {0x8781fc88, 0x355f, 0x4439, { 0x88, 0x1f, 0x65, 0x04, 0xa0, 0xa1, 0xce, 0xb6 }};\n</pre>\n<p>then follow the recipe.\n</p>\n<pre>HWND getHwndB(nsIDOMNode *node){\n  HWND self = NULL;\n  nsresult rv;\n  nsCOMPtr&lt;nsIComponentManager&gt; compMgr;\n  rv = NS_GetComponentManager(getter_AddRefs(compMgr));\n  if (NS_FAILED(rv)){ return self; }\n  nsCOMPtr&lt;nsIAccessibleRetrieval&gt; refp; \n  rv = compMgr-&gt;CreateInstanceByContractID(accRetCID, 0, IAR_IID_OLD, getter_AddRefs(refp));\n  if (NS_FAILED(rv)){ return  self; }\n  nsCOMPtr&lt;nsIAccessible&gt; accnode;\n  rv = refp-&gt;GetAccessibleFor(node, getter_AddRefs(accnode));\n  if(NS_FAILED(rv)){ return self; }\n  void *wh = NULL;\n  nsCOMPtr&lt;nsIAccessibleDocument&gt; accdocnode;\n  rv = accnode-&gt;QueryInterface(IAD_IID_OLD, getter_AddRefs(accdocnode));\n  if(NS_FAILED(rv)){ return self; }\n  rv = accdocnode-&gt;GetWindowHandle(&amp;wh);\n  if(NS_SUCCEEDED(rv)){ self = static_cast&lt;HWND&gt;(wh); }\n  return self;\n}\n</pre>\n<p><br>\nThere is good news and bad news. First the good news. Plan B inside Firefox 2\nhappily runs to completion. All the XPCOM calls succeed, or at least think\nthey succeed. The bad news is that the thing we get back is not a valid <code>HWND</code>.\n</p><p>The problem now is not just interface identifier mismatch, but class declaration\nmismatch. <code>GetWindowHandle</code> is the tenth method declared in the <code>\nnsIAccessibleDocument.h </code>\nthat Firefox 2 was built with, but actually the eighth method in the SDK\nthat I used to build my extension (and hence XPCOM component). Since\nthese classes don't use vtables this means I'm probably, no I can be more positive, definitely calling the wrong method. If I were\na betting man, I'd hedge a bet on <code>GetAccessibleInParentChain</code>,\nthat being the tenth method in the interface declaration in the new SDK. </p><p>In actual fact we were lucky we actually got as far as we did, since\nthe very first interface we made use of has changed substantially. If\nthere is any truth to the story I weave here, then this is because\n<code>GetAccessibleFor</code> is still the very first method declared in\n<code>nsIAccessibleRetrieval.h</code>. So if you are lucky enough with your\nAPI's this technique may work without further ado.\nWe are not so lucky.\n</p><p><br>\n</p>\n<h2 id=\"The_Realist's_Solution\"> The Realist's Solution </h2>\n<p>To make sure we call the right methods of the right interfaces we\nneed to have two versions of both the <code>nsIAccessibleDocument</code> and\n<code>nsIAccessibleRetrieval</code> interfaces at our fingertips. I called my\nold ones: <code>nsIAccessibleRetrieval_old.h</code> and <code>nsIAccessibleDocument_old.h</code>.\n</p><p>Mine date back to August of 2006, which is when I first built\nthe lizard. To get these four files to co-exist together\npeacefully I had to resort to some preprocessor magic and\nan ugly hack. Maybe the ugly hack can be replaced by even\nmore preprocessor magic, but not today. Lets do the magic first, then describe the ugly hack. </p><p>To include both retrieval interfaces (and remember the old IID without having to cut and paste) I followed the kind advice of Mike\nShaver and did:\n</p>\n<pre>#define nsIAccessibleRetrieval nsIAccessibleRetrieval_old \n#include \"accessibility/nsIAccessibleRetrieval_old.h\"\nstatic const nsIID NS_IACCESSIBLERETRIEVAL_IID_OLD = NS_IACCESSIBLERETRIEVAL_IID;\n#undef nsIAccessibleRetrieval \n#undef __gen_nsIAccessibleRetrieval_h__\n#include \"accessibility/nsIAccessibleRetrieval.h\"\n</pre>\n<p>and following the identical principle for the document interface:\n</p>\n<pre>#define nsIAccessibleDocument nsIAccessibleDocument_old \n#include \"accessibility/nsIAccessibleDocument_old.h\" \nstatic const nsIID NS_IACCESSIBLEDOCUMENT_IID_OLD = NS_IACCESSIBLEDOCUMENT_IID;\n#undef nsIAccessibleDocument \n#undef __gen_nsIAccessibleDocument_h__\n#include \"accessibility/nsIAccessibleDocument.h\"\n</pre>\n<p>I even silenced my friend the compiler by enclosing both incantations\nwithin a compiler pragma:\n</p>\n<pre>#pragma warning(push)\n#pragma warning(disableÂ : 4005)\n...\n#pragma warning(pop) \n</pre>\n<p>So now I have to own up to the ugly hack. I did have to delve into my old versions and change:\n</p>\n<pre>   NS_DEFINE_STATIC_IID_ACCESSOR(...)\n</pre>\n<p>to\n</p>\n<pre>   NS_DECLARE_STATIC_IID_ACCESSOR(...)\n</pre>\n<p>This ugliness aside, my plan B routine now looks like:\n</p>\n<pre>HWND getHwndB(nsIDOMNode *node){\n  HWND self = NULL;\n  nsresult rv;\n  nsCOMPtr&lt;nsIComponentManager&gt; compMgr;\n  rv = NS_GetComponentManager(getter_AddRefs(compMgr));\n  if (NS_FAILED(rv)){ return self; }\n  nsCOMPtr&lt;nsIAccessibleRetrieval_old&gt; refp; //N.B. _old\n  rv = compMgr-&gt;CreateInstanceByContractID(accRetCID, 0, \n                                           NS_IACCESSIBLERETRIEVAL_IID_OLD, \n                                           getter_AddRefs(refp));\n  if (NS_FAILED(rv)){ return  self; }\n  nsCOMPtr&lt;nsIAccessible&gt; accnode;\n  rv = refp-&gt;GetAccessibleFor(node, getter_AddRefs(accnode));\n  if(NS_FAILED(rv)){ return self; }\n  void *wh = NULL;\n  nsCOMPtr&lt;nsIAccessibleDocument_old&gt; accdocnode; //N.B. _old\n  rv = accnode-&gt;QueryInterface(NS_IACCESSIBLEDOCUMENT_IID_OLD, \n                               getter_AddRefs(accdocnode));\n  if(NS_FAILED(rv)){ return self; }\n  rv = accdocnode-&gt;GetWindowHandle(&amp;wh);\n  if(NS_SUCCEEDED(rv)){ self = static_cast&lt;HWND&gt;(wh); }\n  return self;\n}\n</pre>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/teoli\">teoli</a>, <a href=\"https://developer.mozilla.org/en-US/profiles/Ianamason\">Ianamason</a>",
    "title": "Working with Multiple Versions of Interfaces"
}