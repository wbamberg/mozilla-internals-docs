{
    "content": "<div>\n <strong style=\"line-height: 1.5;\">An example </strong><span style=\"line-height: 1.5;\">: https://github.com/laurentj/slimerjs/blob/master/src/modules/webserver.jsm</span></div>\n<div>\n  </div>\n<pre class=\"brush: js\">var EXPORTED_SYMBOLS = [\"create\"];\nComponents.utils.import(\"resource://gre/modules/Services.jsm\");\n\nfunction create() {\n    var server = Components.classes[\"@mozilla.org/server/jshttp;1\"]\n                           .createInstance(Components.interfaces.nsIHttpServer);\n    return {\n        get objectName () {\n            return \"WebServer\";\n        },\n\n        /**\n         * @param integer|string port    port or \"host:port\"\n         * @param object opt            optional options. (not supported)\n         * @param function callback     optional callback\n         */\n        listen: function(port, opt, callback) {\n            if (arguments.length == 2 &amp;&amp; \"function\" == typeof opt) {\n                callback = opt;\n            }\n            if (callback) {\n                this.registerPrefixHandler(\"/\", callback);\n            }\n            let host = \"localhost\";\n            if (typeof port === \"string\" &amp;&amp; port.indexOf(':') != -1){\n                [host, port] = port.split(':');\n                port = parseInt(port);\n                server.identity.add('http', host, port);\n            }\n            server.wrappedJSObject._start(port, host);\n            return true;\n        },\n\n        registerFile: function(path, filePath) {\n            var file = Components.classes['@mozilla.org/file/local;1']\n                            .createInstance(Components.interfaces.nsILocalFile);\n            file.initWithPath(filePath);\n            return server.registerFile(path, file);\n        },\n\n        registerDirectory : function(path, directoryPath) {\n            var file = Components.classes['@mozilla.org/file/local;1']\n                            .createInstance(Components.interfaces.nsILocalFile);\n            file.initWithPath(directoryPath);\n            return server.registerDirectory(path, file);\n        },\n\n        registerPathHandler: function(path, handlerCallback) {\n            server.registerPathHandler(path, function (request, response) {\n                    var req = createHttpRequest(request);\n                    var resp = new HttpResponse(response);\n                    handlerCallback(req, resp);\n            });\n        },\n\n        registerPrefixHandler: function(prefix, handlerCallback) {\n            server.registerPrefixHandler(prefix, function (request, response) {\n                    var req = createHttpRequest(request);\n                    var resp = new HttpResponse(response);\n                    handlerCallback(req, resp);\n                });\n        },\n\n        close: function(){\n            server.stop(function(){});\n        },\n        get port() {\n            return server.identity.primaryPort\n        }\n    }\n}\n\n</pre>\n<div>\n <div>\n  <strong>Reference </strong>:  mozilla-release/netwerk/test/httpserver/nsIHttpServer.idl</div>\n <div>\n   </div>\n</div>\n<pre class=\"brush: cpp\">[scriptable, uuid(cea8812e-faa6-4013-9396-f9936cbb74ec)]\ninterface nsIHttpServer : nsISupports\n{\n  /**\n   * Starts up this server, listening upon the given port.\n   *\n   * @param port\n   *   the port upon which listening should happen, or -1 if no specific port is\n   *   desired\n   * @throws NS_ERROR_ALREADY_INITIALIZED\n   *   if this server is already started\n   * @throws NS_ERROR_NOT_AVAILABLE\n   *   if the server is not started and cannot be started on the desired port\n   *   (perhaps because the port is already in use or because the process does\n   *   not have privileges to do so)\n   * @note\n   *   Behavior is undefined if this method is called after stop() has been\n   *   called on this but before the provided callback function has been\n   *   called.\n   */\n  void start(in long port);\n\n  /**\n   * Shuts down this server if it is running (including the period of time after\n   * stop() has been called but before the provided callback has been called).\n   *\n   * @param callback\n   *   an asynchronous callback used to notify the user when this server is\n   *   stopped and all pending requests have been fully served\n   * @throws NS_ERROR_NULL_POINTER\n   *   if callback is null\n   * @throws NS_ERROR_UNEXPECTED\n   *   if this server is not running\n   */\n  void stop(in nsIHttpServerStoppedCallback callback);\n\n  /**\n   * Associates the local file represented by the string file with all requests\n   * which match request.\n   *\n   * @param path\n   *   the path which is to be mapped to the given file; must begin with \"/\" and\n   *   be a valid URI path (i.e., no query string, hash reference, etc.)\n   * @param file\n   *   the file to serve for the given path, or null to remove any mapping that\n   *   might exist; this file must exist for the lifetime of the server\n   */\n  void registerFile(in string path, in nsIFile file);\n\n  /**\n   * Registers a custom path handler.\n   *\n   * @param path\n   *   the path on the server (beginning with a \"/\") which is to be handled by\n   *   handler; this path must not include a query string or hash component; it\n   *   also should usually be canonicalized, since most browsers will do so\n   *   before sending otherwise-matching requests\n   * @param handler\n   *   an object which will handle any requests for the given path, or null to\n   *   remove any existing handler; if while the server is running the handler\n   *   throws an exception while responding to a request, an HTTP 500 response\n   *   will be returned\n   * @throws NS_ERROR_INVALID_ARG\n   *   if path does not begin with a \"/\"\n   */\n  void registerPathHandler(in string path, in nsIHttpRequestHandler handler);\n\n  /**\n   * Registers a custom prefix handler.\n   *\n   * @param prefix\n   *   the path on the server (beginning and ending with \"/\") which is to be\n   *   handled by handler; this path must not include a query string or hash\n   *   component. All requests that start with this prefix will be directed to\n   *   the given handler.\n   * @param handler\n   *   an object which will handle any requests for the given path, or null to\n   *   remove any existing handler; if while the server is running the handler\n   *   throws an exception while responding to a request, an HTTP 500 response\n   *   will be returned\n   * @throws NS_ERROR_INVALID_ARG\n   *   if path does not begin with a \"/\" or does not end with a \"/\"\n   */\n  void registerPrefixHandler(in string prefix, in nsIHttpRequestHandler handler);\n\n  /**\n   * Registers a custom error page handler.\n   *\n   * @param code\n   *   the error code which is to be handled by handler\n   * @param handler\n   *   an object which will handle any requests which generate the given status\n   *   code, or null to remove any existing handler.  If the handler throws an\n   *   exception during server operation, fallback is to the genericized error\n   *   handler (the x00 version), then to 500, using a user-defined error\n   *   handler if one exists or the server default handler otherwise.  Fallback\n   *   will never occur from a user-provided handler that throws to the same\n   *   handler as provided by the server, e.g. a throwing user 404 falls back to\n   *   400, not a server-provided 404 that might not throw.\n   * @note\n   *   If the error handler handles HTTP 500 and throws, behavior is undefined.\n   */\n  void registerErrorHandler(in unsigned long code, in nsIHttpRequestHandler handler);\n\n  /**\n   * Maps all requests to paths beneath path to the corresponding file beneath\n   * dir.\n   *\n   * @param path\n   *   the absolute path on the server against which requests will be served\n   *   from dir (e.g., \"/\", \"/foo/\", etc.); must begin and end with a forward\n   *   slash\n   * @param dir\n   *   the directory to be used to serve all requests for paths underneath path\n   *   (except those further overridden by another, deeper path registered with\n   *   another directory); if null, any current mapping for the given path is\n   *   removed\n   * @throws NS_ERROR_INVALID_ARG\n   *   if dir is non-null and does not exist or is not a directory, or if path\n   *   does not begin with and end with a forward slash\n   */\n  void registerDirectory(in string path, in nsIFile dir);\n\n  /**\n   * Associates files with the given extension with the given Content-Type when\n   * served by this server, in the absence of any file-specific information\n   * about the desired Content-Type.  If type is empty, removes any extant\n   * mapping, if one is present.\n   *\n   * @throws NS_ERROR_INVALID_ARG\n   *   if the given type is not a valid header field value, i.e. if it doesn't\n   *   match the field-value production in RFC 2616\n   * @note\n   *   No syntax checking is done of the given type, beyond ensuring that it is\n   *   a valid header field value.  Behavior when not given a string matching\n   *   the media-type production in RFC 2616 section 3.7 is undefined.\n   *   Implementations may choose to define specific behavior for types which do\n   *   not match the production, such as for CGI functionality.\n   * @note\n   *   Implementations MAY treat type as a trusted argument; users who fail to\n   *   generate this string from trusted data risk security vulnerabilities.\n   */\n  void registerContentType(in string extension, in string type);\n\n  /**\n   * Sets the handler used to display the contents of a directory if\n   * the directory contains no index page.\n   *\n   * @param handler\n   *   an object which will handle any requests for directories which\n   *   do not contain index pages, or null to reset to the default\n   *   index handler; if while the server is running the handler\n   *   throws an exception while responding to a request, an HTTP 500\n   *   response will be returned.  An nsIFile corresponding to the\n   *   directory is available from the metadata object passed to the\n   *   handler, under the key \"directory\".\n   */\n  void setIndexHandler(in nsIHttpRequestHandler handler);\n\n  /** Represents the locations at which this server is reachable. */\n  readonly attribute nsIHttpServerIdentity identity;\n\n  /**\n   * Retrieves the string associated with the given key in this, for the given\n   * path's saved state.  All keys are initially associated with the empty\n   * string.\n   */\n  AString getState(in AString path, in AString key);\n\n  /**\n   * Sets the string associated with the given key in this, for the given path's\n   * saved state.\n   */\n  void setState(in AString path, in AString key, in AString value);\n\n  /**\n   * Retrieves the string associated with the given key in this, in\n   * entire-server saved state.  All keys are initially associated with the\n   * empty string.\n   */\n  AString getSharedState(in AString key);\n\n  /**\n   * Sets the string associated with the given key in this, in entire-server\n   * saved state.\n   */\n  void setSharedState(in AString key, in AString value);\n\n  /**\n   * Retrieves the object associated with the given key in this in\n   * object-valued saved state.  All keys are initially associated with null.\n   */\n  nsISupports getObjectState(in AString key);\n\n  /**\n   * Sets the object associated with the given key in this in object-valued\n   * saved state.  The value may be null.\n   */\n  void setObjectState(in AString key, in nsISupports value);\n};\n</pre>\n<div>\n  </div>",
    "contributors": "<a href=\"https://developer.mozilla.org/en-US/profiles/wbamberg\">wbamberg</a>",
    "title": "nsIHttpServer"
}